{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the BotCommands wiki!","text":"<p>Have a look around the different categories on how to use this framework</p> <p>If you don't find a wiki page you need, you should check out the examples</p>"},{"location":"Logging/","title":"Logging","text":"<p>The library uses a logger, if no logger is present it will only print errors</p> <p>It is strongly advised you use a logger, it doesn't take you much time to add a logback dependency and some generic logback.xml</p> <p>For a logging tutorial, you can follow JDA's Logging tutorial</p> <p>And then you can choose a <code>logback.xml</code> file, which you have to put in the root of your resources (so in Maven at <code>src/main/resources</code>)</p> <p>My personal choice for a <code>logback.xml</code> is as such:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n&lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt;\n\n&lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n&lt;encoder&gt;\n&lt;!-- Debug pattern --&gt;\n&lt;!--&lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldRed(%-36.-36class{36}) %boldRed(#%-24.-24method{24}) %boldRed(L%-5.-5line) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;--&gt;\n&lt;!-- Normal pattern, no stack frames --&gt;\n&lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;\n&lt;/encoder&gt;\n&lt;/appender&gt;\n\n&lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n&lt;file&gt;logs/latest.log&lt;/file&gt;\n&lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n&lt;!-- daily rollover --&gt;\n&lt;fileNamePattern&gt;logs/logs-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;\n\n&lt;!-- keep 90 days' worth of history capped at 3GB total size --&gt;\n&lt;maxHistory&gt;90&lt;/maxHistory&gt;\n&lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;\n&lt;/rollingPolicy&gt;\n\n&lt;encoder&gt;\n&lt;pattern&gt;%d{HH:mm:ss.SSS} %-26.-26thread %-36.-36class{36} #%-24.-24method{24} L%-5.-5line %-20.-20logger{0} %-6level %msg%n%throwable&lt;/pattern&gt;\n&lt;/encoder&gt;\n&lt;/appender&gt;\n\n&lt;!-- Log JDA and HikariCP on Info while others are on Debug --&gt;\n&lt;logger name=\"net.dv8tion.jda\" level=\"info\" additivity=\"false\"&gt;\n&lt;appender-ref ref=\"STDOUT\"/&gt;\n&lt;appender-ref ref=\"FILE\"/&gt;\n&lt;/logger&gt;\n\n&lt;logger name=\"com.zaxxer.hikari\" level=\"info\" additivity=\"false\"&gt;\n&lt;appender-ref ref=\"STDOUT\"/&gt;\n&lt;appender-ref ref=\"FILE\"/&gt;\n&lt;/logger&gt;\n\n&lt;root level=\"debug\"&gt;\n&lt;appender-ref ref=\"STDOUT\"/&gt;\n&lt;appender-ref ref=\"FILE\"/&gt;\n&lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"misc/Conditional-instancing/","title":"Conditional instancing","text":"<p>Conditional instancing lets you enable classes (they may be commands, component handlers or event handlers...) with a predicate method.</p> <p>The predicate is called when the class is trying to get instantiated, if the predicate returns false, the class will not be instantiated (so the constructor won't run)</p>"},{"location":"misc/Conditional-instancing/#requirements","title":"Requirements","text":"<ul> <li>The method must be public and static</li> <li>It must return a boolean</li> <li>It does not accept any arguments</li> </ul>"},{"location":"misc/Conditional-instancing/#example","title":"Example","text":"<p>Suppose you have a <code>/windows</code> command that only works on Windows, and a <code>/linux</code> command that only works on Linux</p> <pre><code>public class WindowsCommand extends ApplicationCommand {\n@ConditionalUse //Called when the class is about to get constructed\npublic static boolean canUse() { //Return false if it's not Windows\nreturn System.getProperty(\"os.name\").toLowerCase().contains(\"windows\");\n}\n\n@JDASlashCommand(name = \"windows\")\npublic void execute(GuildSlashEvent event) {\nevent.reply(\"The bot runs on Windows\").setEphemeral(true).queue();\n}\n}\n</code></pre> <pre><code>public class LinuxCommand extends ApplicationCommand {\n@ConditionalUse //Called when the class is about to get constructed\npublic static boolean canUse() { //Return false if it's not Linux\nfinal String osName = System.getProperty(\"os.name\").toLowerCase();\n\nreturn osName.contains(\"linux\") || osName.contains(\"nix\"); //Not accurate but should do it, not tested\n}\n\n@JDASlashCommand(name = \"linux\")\npublic void execute(GuildSlashEvent event) {\nevent.reply(\"The bot runs on Linux\").setEphemeral(true).queue();\n}\n}\n</code></pre> <p>This would make these commands enable themselves when the running OS corresponds</p>"},{"location":"misc/Instance-suppliers/","title":"Using instance suppliers","text":"<p>Maybe you have some use case where you would need to manually instantiate a command class</p> <p>For this, you can register the instances directly in the <code>ExtensionsBuilder#registerInstanceSupplier</code></p>"},{"location":"misc/Instance-suppliers/#how-to-use-it","title":"How to use it","text":"<p>You can register the instance supplier with <code>ExtensionsBuilder#registerInstanceSupplier</code></p>"},{"location":"misc/Instance-suppliers/#example","title":"Example","text":"<pre><code>CommandsBuilder.newBuilder()\n.extensionsBuilder(extensionsBuilder -&gt;\nextensionsBuilder.registerInstanceSupplier(SlashInstanceSupplierTest.class, ignored -&gt; new SlashInstanceSupplierTest(new SlashInstanceSupplierTest.Dummy()))\n)\n.build(jda, \"com.freya02.bot.wiki.instancesupplier.commands\");\n</code></pre>"},{"location":"misc/Instance-suppliers/#checking-that-it-works","title":"Checking that it works","text":"<pre><code>public class SlashInstanceSupplierTest extends ApplicationCommand {\nprivate static final Logger LOGGER = Logging.getLogger();\n\npublic static class Dummy {}\n\n//Making a non-instantiable constructor so only I can construct it\npublic SlashInstanceSupplierTest(Dummy dummy) {\nLOGGER.debug(\"I got constructed with {}\", dummy);\n}\n\n@JDASlashCommand(name = \"instancesupplier\")\npublic void run(GuildSlashEvent event) {\nevent.reply(\"I ran\").queue();\n}\n}\n</code></pre>"},{"location":"misc/The-event-waiter/","title":"Using the event waiter","text":"<p>You might have situations where you want to wait for any JDA event to occur,      for this you could use an event waiter,      even if sometimes a state machine is better,      in cases when you need to wait for multiple events sequentially</p> <p>No setup is required to use the event waiter, just use the static method <code>EventWaiter#of</code></p>"},{"location":"misc/The-event-waiter/#example-simon-says","title":"Example - Simon says","text":"<p>The following example uses most of what you'll need:</p> <pre><code>@Description(\"Do what Simon says\")\npublic class SlashWaiterTest extends TextCommand {\n@JDATextCommand(name = \"simon\")\npublic void execute(CommandEvent event) {\nevent.reply(\"Simon says: say `hi` in less than 5 seconds\").queue(m -&gt; {\nEventWaiter.of(GuildMessageReceivedEvent.class) //Listen to guild messages\n//Check for the same channel\n.addPrecondition(e -&gt; e.getChannel().equals(event.getChannel()))\n\n//You can add as many preconditions,\n// this would avoid doing combinations of booleans in 1 predicate\n\n//Check for same author, with message \"hi\"\n.addPrecondition(e -&gt; e.getAuthor().equals(event.getAuthor()) &amp;&amp; e.getMessage().getContentRaw().equals(\"hi\"))\n\n//Expire on 5 seconds\n.setTimeout(5, TimeUnit.SECONDS)\n\n//After event waiter has expired, send a timeout message\n.setOnTimeout(() -&gt; m.reply(\"Timeout !\").queue())\n\n//After the preconditions have been fulfilled, reply\n.setOnSuccess(e -&gt; e.getMessage().reply(\"n i c e\").queue())\n\n//Wait for the event (non-blocking)\n.submit();\n});\n}\n}\n</code></pre>"},{"location":"using-commands/Context-menu-commands/","title":"Writing context menu commands","text":"<p>Context commands are these commands when you right-click on a message, or on a user, and executes an interaction, similarly to slash commands</p>"},{"location":"using-commands/Context-menu-commands/#a-few-keywords","title":"A few keywords","text":"<ul> <li><code>[Type]</code> is either User or Message</li> <li><code>ApplicationCommand</code> - Must be extended by the class which contains applications commands</li> <li><code>@AppOption</code> - Mandatory on options</li> <li><code>@JDA[Type]Command</code> - Annotation for methods which marks context commands</li> </ul>"},{"location":"using-commands/Context-menu-commands/#making-context-commands","title":"Making context commands","text":"<p>A context command is similar to a slash command - You extend <code>ApplicationCommand</code> on your class and use <code>@JDA[Type]Command</code> on every method you want to be a context menu command</p> <p>Your method has to: * Be public * Have <code>Guild[Type]Event</code> (for guild-only context commands, if not specified explicitly, a context command is guild-only) as first parameter, or a <code>Global[Type]Event</code> for global commands * Be annotated <code>@JDA[Type]Command</code></p>"},{"location":"using-commands/Context-menu-commands/#examples","title":"Examples","text":"Basic <code>Quote message</code> message command <pre><code>public class ContextQuote extends ApplicationCommand {\n@JDAMessageCommand(name = \"Quote message\")\npublic void execute(GuildMessageEvent event) {\nfinal Message targetMessage = event.getTargetMessage();\n\nevent.reply(\"&gt; \" + targetMessage.getContentRaw()).queue();\n}\n}\n</code></pre> Basic <code>Get avatar user</code> command <pre><code>public class ContextAvatar extends ApplicationCommand {\n@JDAUserCommand(name = \"Get avatar\")\npublic void execute(GuildUserEvent event) {\nfinal User targetUser = event.getTargetUser();\n\nevent.reply(targetUser.getEffectiveAvatarUrl()).queue();\n}\n}\n</code></pre>"},{"location":"using-commands/Context-menu-commands/#updating-existing-context-commands-on-the-fly","title":"Updating existing context commands on the fly","text":"<p>See the Updating existing commands page</p>"},{"location":"using-commands/Inferred-option-names/","title":"Inferred option names","text":"<p>For annotations such as <code>@TextOption</code> or <code>@AppOption</code>, you would need to set a <code>name</code> attribute on them,  so it can be displayed on Discord</p> <p>Fortunately, you can make the library take the name of your parameter as the name for your option,  all you have to do is to tell your compiler(s) to put the parameter metadata in the compiled classes</p> <p>This should make your code a bit cleaner</p>"},{"location":"using-commands/Inferred-option-names/#adding-java-kotlin-parameters-for-maven","title":"Adding Java &amp; Kotlin parameters for Maven","text":""},{"location":"using-commands/Inferred-option-names/#java","title":"Java","text":"<p>You can add this in your <code>configuration</code> tag: <pre><code>&lt;plugin&gt;\n&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;version&gt;${compiler.plugin.version}&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;${java.version}&lt;/source&gt;\n&lt;target&gt;${java.version}&lt;/target&gt;\n&lt;compilerArgs&gt; &lt;!-- Add this --&gt;\n&lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n&lt;/compilerArgs&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre></p>"},{"location":"using-commands/Inferred-option-names/#kotlin","title":"Kotlin","text":"<p>You can add this in your <code>configuration</code> tag: <pre><code>&lt;plugin&gt;\n&lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;\n&lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;${kotlin.version}&lt;/version&gt;\n&lt;executions&gt;...&lt;/executions&gt;\n&lt;configuration&gt;\n&lt;args&gt; &lt;!-- Add this --&gt;\n&lt;arg&gt;-java-parameters&lt;/arg&gt;\n...\n        &lt;/args&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre></p>"},{"location":"using-commands/Inferred-option-names/#adding-java-kotlin-parameters-for-gradle","title":"Adding Java &amp; Kotlin parameters for Gradle","text":""},{"location":"using-commands/Inferred-option-names/#java_1","title":"Java","text":"<p>You can add this in your <code>build.gradle</code>: <pre><code>compileJava {\n    compilerArgs += '-parameters'\n}\n</code></pre></p>"},{"location":"using-commands/Inferred-option-names/#kotlin_1","title":"Kotlin","text":"<p>You can add this in your <code>build.gradle</code>: <pre><code>compileKotlin {\n    kotlinOptions.javaParameters = true\n}\n</code></pre></p>"},{"location":"using-commands/Prefixed-commands/","title":"Writing prefixed commands","text":""},{"location":"using-commands/Prefixed-commands/#a-few-keywords","title":"A few keywords","text":"<ul> <li><code>TextCommand</code> - The class which should be inherited by every (regex) prefixed command</li> <li><code>BContext</code> - The BotCommands context, it can help you get the <code>JDA</code> instance, check if someone is a bot (co)owner, get the default embeds, add/remove filters and much more</li> <li><code>CommandEvent</code> - The event object received when a command is used, it extends <code>GuildMessageReceivedEvent</code> and provides more functions to help parse the command arguments</li> <li><code>#hasNext(Class&lt;T&gt;)</code>, <code>#peekArgument(Class&lt;T&gt;)</code> and <code>#nextArgument(Class&lt;T&gt;)</code> accepts classes such as strings and mentionables (user / member / text channel / role)</li> <li><code>#resolveNext(Class&lt;?&gt;...)</code> tries to resolve mentionables either from the full mention or from just a given ID, throwing an exception if it is not resolvable</li> <li><code>@Hidden</code> - Hides a command from help content and from being used by non-owners</li> <li><code>@RequireOwner</code> - Makes a command usable only by bot (co)owners</li> </ul>"},{"location":"using-commands/Prefixed-commands/#making-a-prefixed-command","title":"Making a prefixed command","text":"<p>To make a valid prefixed command, you need to extend <code>TextCommand</code> and to have methods which are annotated with <code>@JDATextCommand</code></p> <p>There's attributes that are inheritable - so you can place them on the class instead of the individual methods, such as: * Category * Description * Bot / User permission</p>"},{"location":"using-commands/Prefixed-commands/#regex-based-commands","title":"Regex based commands","text":"<ul> <li>These commands have their method signature translated to a regex on runtime, it then converts the groups into your method parameters automatically</li> <li>Their parameters need to be annotated with @TextOption</li> <li>The commands can have a parsing order if you specify it in the command annotation</li> </ul> <p>Be aware:</p> <ul> <li>The order of the methods might be important, only the first method which matches the regex is run</li> <li>Changing the order of the methods at a source code level is not reliable, to fix this, specify the <code>order</code> value in the <code>@JDATextCommand</code> annotation on each method</li> <li>Strings are a common way of making these commands not work correctly, depending on how many there are and where they are placed in your parameters, the framework will throw at startup if a command is \"too complex\"</li> </ul> <p>Example: <pre><code>@CommandMarker //No unused warnings\n@Category(\"Utils\")\n@Description(\"Gives information about an entity\")\npublic class Info extends TextCommand {\n//Specifying the order makes it so methods have priorities, this is useful in this command because TextChannel, Role and Guild might have the same ids\n// (example: @everyone, the first text channel created and the guild has the same id)\n@JDATextCommand(name = \"info\", order = 1) //Method to be checked first\npublic void exec(BaseCommandEvent event,\n@TextOption Member member) { //@TextOption is mandatory on parameters that have to be parsed\n//Show member info\n}\n\n@JDATextCommand(name = \"info\", order = 2)\npublic void exec(BaseCommandEvent event, @TextOption User user) {\n//Show user info\n}\n}\n</code></pre></p>"},{"location":"using-commands/Prefixed-commands/#fallback-commands","title":"Fallback commands","text":"<p>If none of the regex patterns matched, if this method exists then it's going to get called, otherwise, help content is shown</p> <p>Example: <pre><code>@CommandMarker //No unused warnings\n@Category(\"Utils\")\n@Description(\"Gives the ping of the bot\")\npublic class Ping extends TextCommand {\n@JDATextCommand(name = \"ping\")\npublic void exec(CommandEvent event) { //Fallback CommandEvent\nfinal long gatewayPing = event.getJDA().getGatewayPing();\nevent.getJDA().getRestPing()\n.queue(l -&gt; event.replyFormat(\"Gateway ping: **%d ms**\\nRest ping: **%d ms**\", gatewayPing, l).queue());\n}\n}\n</code></pre></p>"},{"location":"using-commands/Prefixed-commands/#adding-alternative-prefixes","title":"Adding alternative prefixes","text":"<p>You can add alternative prefixes if you have a <code>SettingsProvider</code> such as:</p> <pre><code>public class PrefixSettingsProvider implements SettingsProvider {\n@Override\n@Nullable\npublic List&lt;String&gt; getPrefixes(@NotNull Guild guild) {\nif (guild.getIdLong() == 722891685755093072L) {\nreturn List.of(\"^\"); //Only the prefix \"^\" will be used for the guild ID above\n}\n\nreturn SettingsProvider.super.getPrefixes(guild);\n}\n}\n</code></pre> <p>You can then register your <code>SettingsProvider</code> by adding <code>#setSettingsProvider(new PrefixSettingsProvider())</code> to your CommandsBuilder chain</p>"},{"location":"using-commands/Prefixed-commands/#replacing-help-content","title":"Replacing help content","text":"<p>You can replace the default help command by making a text command with the same path. Your help command needs to implement <code>IHelpCommand</code> so that the help is still displayed when commands are detected, but their syntax is invalid</p> <p>You can also not provide an help implementation and just disable the command with <code>TextCommandsBuilder#disableHelpCommand</code></p> <p>You can also modify the help embeds with <code>TextCommandsBuilder#setHelpBuilderConsumer</code></p>"},{"location":"using-commands/Using-localization/","title":"Using localization","text":"<p>Localization lets you translate commands &amp; responses to the user's or the guild's language, all languages supported by Discord are supported by the framework, you can find a list of languages in JDA's <code>DiscordLocale</code>.</p>"},{"location":"using-commands/Using-localization/#localization-files","title":"Localization files","text":"<p>Localization can be stored in the JSON format and can contain your command translations, as well as command responses, or any other string.</p>"},{"location":"using-commands/Using-localization/#where-do-i-store-them","title":"Where do I store them ?","text":"<p>Localization files must be stored in the <code>bc_localization</code> folder, in your <code>resources</code> directory,  these files can be of any base name, but must end with the locale's string, and must have a <code>.json</code> extension.</p> <p>Examples:</p> <ul> <li>Default localization for the <code>MyLocalizations</code> bundle: <code>MyLocalizations.json</code></li> <li>English localization for the <code>MyLocalizations</code> bundle: <code>MyLocalizations_en.json</code></li> <li>UK localization for the <code>MyLocalizations</code> bundle: <code>MyLocalizations_en_GB.json</code></li> </ul>"},{"location":"using-commands/Using-localization/#what-do-they-look-like","title":"What do they look like ?","text":"<p>The JSON file is going to be an object, with each key being the \"localization key\" and the value being the \"localization template\".</p> <p>The localization key is a string where keywords are separated by a dot, the framework takes advantage of JSON as you can nest objects with their translations inside, the path to the nested translation will be your localization key,  but they can look exactly like the keys in Java's <code>ResourceBundle</code>, where no nesting is required.</p> Example without nesting <pre><code>{\n\"ban.name\": \"ban\",\n\"ban.description\": \"Bans an user\"\n}\n</code></pre> Example with nesting <pre><code>{\n\"ban\": {\n\"name\": \"ban\",\n\"description\": \"Bans an user\"\n}\n}\n</code></pre>"},{"location":"using-commands/Using-localization/#what-are-localization-templates","title":"What are localization templates ?","text":"<p>Localization templates are going to determine how your localized strings will include runtime values. </p> <p>The default localization templates works the same as Java's MessageFormat, except it accepts named arguments instead of indexes. In a nutshell, you can either have basic templates such as <code>This message will delete itself in {deleteTime} seconds</code>, or have complex templates which will accept the argument name, the format type and the format style.</p> Example - <code>/ban</code> success message /resources/bc_localization/MyCommandsLocalization.json<pre><code>{\n\"ban.success\": \"{bannedUser} was banned successfully for the reason '{reason}', and {delHours} {delHours, choice, 1#hour|2&lt;hours} of messages were deleted\"\n}\n</code></pre> <p>Don't forget <code>@LocalizationBundle(\"MyCommandsLocalization\")</code> to use your localization bundle !</p> Ban.java<pre><code>final String response = event.localize(\"ban.success\",\nentry(\"bannedUser\", targetUser.getAsMention()),\nentry(\"delHours\", delHours), // (1)\nentry(\"reason\", reason)\n);\n\nevent.reply(response).queue();\n</code></pre> <ol> <li>The hours of messages being deleted can use different wording depending on plurality,      this is reflected on the localization templates with a <code>choice</code> format type, and a choice format</li> </ol>"},{"location":"using-commands/Using-localization/#localizing-default-messages","title":"Localizing default messages","text":"<p>Default messages are messages that can be sent by the framework itself, they can come from the command listeners, components or modals for example. </p>"},{"location":"using-commands/Using-localization/#replacing-default-messages","title":"Replacing default messages","text":"<p>Default messages are defined in <code>/resources/bc_localization/DefaultMessages.json</code>, this is where you can find all the localization keys used by the framework.</p> <p>To override one or more default messages, create your own <code>DefaultMessages.json</code>, like you would with a normal localization file.</p> /resources/bc_localization/DefaultMessages.json<pre><code>{\n\"general_error_message\": \"The bot has encountered an error, try again later.\"\n}\n</code></pre>"},{"location":"using-commands/Using-localization/#adding-translations-to-default-messages","title":"Adding translations to default messages","text":"<p>Default messages can also be localized, but they must keep the same base name, i.e. <code>DefaultMessages</code>.</p> /resources/bc_localization/DefaultMessages_fr.json<pre><code>{\n\"general_error_message\": \"Le bot a rencontr\u00e9 une erreur, veuillez r\u00e9essayer plus tard.\"\n}   </code></pre>"},{"location":"using-commands/Using-localization/#localizing-application-commands","title":"Localizing application commands","text":"<p>Only application commands supports localization, translations can include names and description of commands as well as options, and also choice names.</p> <p>You will need to indicate to the framework which localization files are available, and which languages they support. This can be done with <code>ApplicationCommandsBuilder#addLocalizations</code>, such as:</p> Main.java<pre><code>CommandsBuilder builder = ...;\nbuilder.applicationCommandBuilder(applicationCommandsBuilder -&gt; applicationCommandsBuilder\n.addLocalizations(\"LocalizationWikiCommands\", DiscordLocale.ENGLISH_US) // (1)\n);\n</code></pre> <ol> <li> <p>This enables localization from the <code>LocalizationWikiCommands.json</code> bundle, in the <code>en_US</code> language. (i.e. <code>LocalizationWikiCommands_en_US.json</code>)</p> <p>If you wish to add more localizations, add a <code>DiscordLocale</code> here, and create the corresponding files.</p> </li> </ol> <p>You can then create your commands as you would normally, no need to set up special names or anything.</p> <p>Your localization keys will be the same as specified by JDA's <code>LocalizationFunction</code>,  which means the keys are composed of the complete path, combined with the option's name and the choice's name as well, please refer to the JDA documentation for more details.</p> <p>An example can be found here</p>"},{"location":"using-commands/Using-localization/#inferred-command-and-option-descriptions","title":"Inferred command and option descriptions","text":"<p>Application command descriptions and option descriptions can be retrieved from the \"root\" localization bundles,  i.e. localization bundles without a language specified, such as <code>LocalizationWikiCommands.json</code></p>"},{"location":"using-commands/Using-localization/#localizing-responses","title":"Localizing responses","text":"<p>Localizing responses can be done using the framework's events, with the <code>localize</code> methods and its overloads. The method uses the best locale available, depending on the context:</p> <ul> <li>Any type of Interaction: Uses the user's locale</li> <li>Other events: Uses the Guild's locale (US English by default)</li> </ul> <p>Let's say someone used a ban command, but the caller cannot ban the user, due to hierarchy reasons:</p> SlashBan.java<pre><code>final String errorMessage = event.localize( // (1)\n\"ban.caller.interact_error\", entry(\"mention\", targetMember.getAsMention())  // (2)\n); event.reply(errorMessage).queue();\n</code></pre> <ol> <li>This will use the user's locale, as a slash command is an interaction.</li> <li>\"mention\" is a variable of the string template</li> </ol>"},{"location":"using-commands/Using-localization/#example-project","title":"Example project","text":"<p>You can also see this very small bot using localization: Link</p>"},{"location":"using-commands/updating-application-commands/Slash-commands---Updating-option-choices/","title":"Slash commands - Updating option choices","text":"<p>See here  the example on how to add predefined choices to your slash commands</p> <p>You can also change the <code>GuildApplicationSettings#getOptionChoices</code> to provide dynamic values,  for example if you have a command that adds choices, you would add the choice to the list and then call  <code>BContext#scheduleApplicationCommandsUpdate</code> to update the application commands with the new choices</p> <p>Example - How to make a dynamic choice list, having a command to add choices</p> <pre><code>public class SlashChoices extends ApplicationCommand {\nprivate static final Logger LOGGER = Logging.getLogger();\n\nprivate final List&lt;Command.Choice&gt; valueList = new ArrayList&lt;&gt;();\n\n@Override\n@NotNull\npublic List&lt;Command.Choice&gt; getOptionChoices(@Nullable Guild guild, @NotNull CommandPath commandPath, int optionIndex) {\nif (optionIndex == 0) {\nreturn valueList;\n}\n\nreturn List.of();\n}\n\n@JDASlashCommand(name = \"choices\", subcommand = \"choose\")\npublic void choose(GuildSlashEvent event,\n@AppOption(description = \"The value you choose\") String value) {\nevent.reply(\"Your choice: \" + value)\n.setEphemeral(true)\n.queue();\n}\n\n@JDASlashCommand(name = \"choices\", subcommand = \"add\")\npublic void addChoice(GuildSlashEvent event,\n@AppOption(description = \"The name of the choice\") String name,\n@AppOption(description = \"The value of the choice\") String value) {\nevent.deferReply(true).queue();\n\nvalueList.add(new Command.Choice(name, value));\n\n//You should handle the exceptions inside the completable future, in case an error occurred\nevent.getContext().scheduleApplicationCommandsUpdate(event.getGuild(), false, false);\n\nevent.getHook().sendMessage(\"Choice added successfully\").queue();\n}\n}\n</code></pre>"},{"location":"using-commands/using-slash-commands/Managing-application-commands/","title":"Adding or removing application commands from certain Guilds","text":"<p>You can specify which application commands are available on a per-guild basis by using a <code>SettingsProvider</code></p> <p>You do need to set the <code>SettingsProvider</code> with <code>CommandsBuilder#setSettingsProvider</code></p> <p>Suppose you have a slash command <code>/info</code>:</p> The <code>/info</code> command <pre><code>public class SlashInfo extends ApplicationCommand {\n@JDASlashCommand(name = \"info\", subcommand = \"user\")\npublic void userInfo(GuildSlashEvent event, @AppOption User user) {\nevent.reply(\"User: \" + user).queue();\n}\n\n@JDASlashCommand(name = \"info\", subcommand = \"channel\")\npublic void channelInfo(GuildSlashEvent event, @AppOption TextChannel channel) {\nevent.reply(\"Channel: \" + channel).queue();\n}\n\n@JDASlashCommand(name = \"info\", subcommand = \"role\")\npublic void roleInfo(GuildSlashEvent event, @AppOption Role role) {\nevent.reply(\"Role: \" + role).queue();\n}\n}\n</code></pre> <p>You then want this command to be disabled by default in every guild (so require a later manual activation by Guild moderators for example):</p> The <code>BasicSettingsProvider</code> class <pre><code>public class BasicSettingsProvider implements SettingsProvider {\nprivate static final Logger LOGGER = Logging.getLogger();\nprivate final Map&lt;Long, List&lt;String&gt;&gt; disabledCommandsMap = new HashMap&lt;&gt;();\nprivate final BContext context;\n\npublic BasicSettingsProvider(BContext context) {\nthis.context = context;\n}\n\n@Override\n@NotNull\npublic CommandList getGuildCommands(@NotNull Guild guild) {\nreturn CommandList.notOf(getBlacklist(guild));\n}\n\n@NotNull\nprivate List&lt;String&gt; getBlacklist(Guild guild) {\n//Blacklist filter - the ArrayList is created only if the guild's ID was not already in the map.\nreturn disabledCommandsMap.computeIfAbsent(guild.getIdLong(), x -&gt; {\nfinal ArrayList&lt;String&gt; disabledCommands = new ArrayList&lt;&gt;();\n\n//Let's say the info command is disabled by default\ndisabledCommands.add(\"info\");\n\nreturn disabledCommands;\n});\n}\n\n//This is for the part where you want to update the command list later\n// So you can use this method to \"enable\" an application command for a guild\n// For example in a text command\npublic void addCommand(Guild guild, String commandName) {\ngetBlacklist(guild).remove(commandName); //Removes the command from the blacklist\n\n//You should handle the exceptions inside the completable future, in case an error occurred\ncontext.scheduleApplicationCommandsUpdate(guild, false, false);\n}\n}\n</code></pre> <p>You can then simply set the <code>SettingsProvider</code> in <code>CommandsBuilder</code>:</p> How to set the settings provider <pre><code>var builder = CommandsBuilder.withPrefix(...)\nbuilder\n.setSettingsProvider(new BasicSettingsProvider(builder.getContext()))\n...\n.build(...);\n</code></pre>"},{"location":"using-commands/using-slash-commands/Slash-commands/","title":"Writing slash commands","text":"<p>Slash commands are the new way of defining commands, even though there are limitations with them, we do have some advantages such as auto-completion and much easier parsing - things that regular commands can't do reliably</p>"},{"location":"using-commands/using-slash-commands/Slash-commands/#a-few-keywords","title":"A few keywords","text":"<ul> <li><code>ApplicationCommand</code> - Must be extended by the class which contains applications commands</li> <li><code>@AppOption</code> - Mandatory on options, also allows you to set the option name and description, by default the name is the parameter name (of the method) and description is <code>No description</code></li> <li><code>@JDASlashCommand</code> - Annotation for methods which marks slash commands</li> </ul>"},{"location":"using-commands/using-slash-commands/Slash-commands/#making-a-slash-command","title":"Making a slash command","text":"<p>A slash command is similar to a regex prefixed command - You extend <code>ApplicationCommand</code> on your class and use <code>@JDASlashCommand</code> on every method you want to be a slash command</p> <p>Your method has to:</p> <ul> <li>Be public</li> <li>Have <code>GuildSlashEvent</code> (for guild-only slash commands, if not specified explicitly, a slash command is guild-only) as first parameter, or a <code>GlobalSlashEvent</code> for global commands</li> <li>Be annotated <code>@JDASlashCommand</code></li> </ul>"},{"location":"using-commands/using-slash-commands/Slash-commands/#examples","title":"Examples","text":"Basic <code>/ping</code> command <pre><code>public class SlashPing extends ApplicationCommand {\n@JDASlashCommand(\nscope = CommandScope.GLOBAL,\nname = \"ping\",\ndescription = \"Pong !\"\n)\npublic void onPing(GlobalSlashEvent event) {\nevent.deferReply().queue();\n\nfinal long gatewayPing = event.getJDA().getGatewayPing();\nevent.getJDA().getRestPing()\n.queue(l -&gt; event.getHook()\n.sendMessageFormat(\"Gateway ping: **%d ms**\\nRest ping: **%d ms**\", gatewayPing, l)\n.queue());\n}\n}\n</code></pre> Example with choices <pre><code>public class SlashSay extends ApplicationCommand {\n// If the method is placed in the same file then it is guaranteed to be only the \"say\" command path,\n// so it won't interfere with other commands\n@Override\n@NotNull\npublic List&lt;Command.Choice&gt; getOptionChoices(@Nullable Guild guild, @NotNull CommandPath commandPath, int optionIndex) {\nif (optionIndex == 0) { //First option\nreturn List.of(\n//Only choices here are \"Hi\" and \"Hello\" and gets \"translated\" to their respective values\nnew Command.Choice(\"Hi\", \"Greetings, comrad\"),\nnew Command.Choice(\"Hello\", \"Oy\")\n);\n}\n\nreturn List.of();\n}\n\n@JDASlashCommand(\n//This command is guild-only by default\nname = \"say\",\ndescription = \"Says what you type\"\n)\npublic void say(GuildSlashEvent event,\n//Option name is by default the parameter name\n@AppOption(description = \"What you want to say\") String text) {\nevent.reply(\"Your choice: \" + text).queue();\n}\n}\n</code></pre>"},{"location":"using-commands/using-slash-commands/Updating-slash-commands/","title":"Updating existing commands on the fly","text":"<p>Let's say a Guild moderator decides to enable the /info command in his Guild, you would need to take your <code>BasicSettingsProvider</code> (from <code>BContext#getSettingsProvider</code>), cast it to your class and then use a method to remove the command from the Guild's blacklist, then finally call <code>BContext#scheduleApplicationCommandsUpdate</code> to update the commands and the slash commands local cache</p> <p>How to enable back the command and update the slash commands list - Using a regular command</p> <pre><code>@Category(\"Moderation\")\n@UserPermissions(Permission.MANAGE_ROLES)\npublic class EnableInfoCommand extends TextCommand {\n@JDATextCommand(\nname = \"enableinfocommand\",\ndescription = \"Enables the /info command\"\n)\npublic void execute(CommandEvent event) {\nif (event.getMember().canInteract(event.getGuild().getSelfMember())) {\nfinal BasicSettingsProvider settingsProvider = (BasicSettingsProvider) event.getContext().getSettingsProvider();\n\nif (settingsProvider == null) {\nevent.indicateError(\"No settings provider has been set\").queue();\n\nreturn;\n}\n\nsettingsProvider.addCommand(event.getGuild(), \"info\");\n\nevent.reactSuccess().queue();\n} else {\nevent.indicateError(\"You cannot do this\").queue();\n}\n}\n}\n</code></pre>"},{"location":"using-components/Buttons/","title":"About buttons","text":""},{"location":"using-components/Buttons/#how-can-i-use-them","title":"How can I use them ?","text":"<p>You'll first need to have some experience using JDA's buttons directly</p> <p>You will need to have your <code>ComponentManager</code> set up in order to use the Components API, which is where the buttons are created.</p> <p>You can then use the <code>Components</code> class methods such as <code>Components#primaryButton</code>, which is equivalent to JDA's <code>Button#primary</code>, except it will give you a builder class where you can set the properties defined in the Components API wiki</p>"},{"location":"using-components/Buttons/#how-to-listen-to-button-clicks","title":"How to listen to button clicks","text":"<p>You have to make a method annotated with <code>@JDAButtonListener</code> and have their first parameter be a <code>ButtonEvent</code></p> <p>Example: <pre><code>@JDAButtonListener(name = \"test\")\npublic void testButtonListener(ButtonEvent event) {\nevent.reply(\"test\").setEphemeral(true).queue();\n}\n</code></pre></p>"},{"location":"using-components/Buttons/#more-examples","title":"More examples","text":"<p>You can see more examples in the examples directory</p>"},{"location":"using-components/Selection-menus/","title":"About selection menus","text":"<p>Select menus can be of 2 types: string select menus, and, entity select menus. You can read more about them on JDA's wiki.</p>"},{"location":"using-components/Selection-menus/#how-can-i-use-them","title":"How can I use them ?","text":""},{"location":"using-components/Selection-menus/#prerequisites","title":"Prerequisites","text":"<p>You will need to setup the <code>ComponentManager</code> first, in order to use these components. You can set it up here</p>"},{"location":"using-components/Selection-menus/#creating-selection-menu","title":"Creating selection menu","text":"<p>The <code>Components</code> class lets you create selection menus with <code>Components.stringSelectionMenu</code>, and <code>Components.entitySelectionMenu</code>.</p> <p>How to create string select menus</p> <pre><code>final StringSelectMenu selectMenu = Components.stringSelectionMenu(\nROLEPLAY_LABEL_SELECT_MENU_LISTENER, // Name of the listener, it is a constant in the class\nThreadLocalRandom.current().nextLong() // A random number we'll pass to the listener, for demonstration\n)\n.oneUse() // (1)\n.setPlaceholder(\"Choose a roleplay label\")\n.addOption(\"Option 1\", \"Label 1\")\n.addOption(\"Option 2\", \"Label 2\")\n.addOption(\"Option 3\", \"Label 3\")\n.build();\n\nevent.replyComponents(ActionRow.of(selectMenu)).queue();\n</code></pre> <ol> <li>This makes the select menu usable only once, but keep in mind that the framework won't delete it from the message.</li> </ol> <p>Warning</p> <p>The methods from the framework (such as <code>oneUse</code> or <code>onTimeout</code>) needs to be used first. You can then use JDA's methods.</p>"},{"location":"using-components/Selection-menus/#handling-selection-events","title":"Handling selection events","text":"<p>You have to make a method annotated with <code>@JDASelectionMenuListener</code>  and have their first parameter be a <code>StringSelectionEvent</code>, or a <code>EntitySelectionEvent</code>, depending on what component you are using.</p> <p>Example: SlashRoleplay.java<pre><code>private static final String ROLEPLAY_LABEL_SELECT_MENU_LISTENER = \"SlashRoleplay: roleplayLabelSelectMenu\"\nprivate static final String AUTO_ROLE_SELECT_MENU_LISTENER = \"SlashRoleplay: autoRoleSelectMenu\"\n\n@JDASelectionMenuListener(name = ROLEPLAY_LABEL_SELECT_MENU_LISTENER)\npublic void onRoleplayLabelSelected(StringSelectionEvent event, @AppOption long randomNumber) { // Number we got back from when we created the selection menu\nevent.replyFormat(\"My random number is %d and your labels have been set to: %s\", randomNumber, event.getValues())\n.setEphemeral(true)\n.queue();\n}\n\n//If you were to create an entity select menu\n@JDASelectionMenuListener(name = AUTO_ROLE_SELECT_MENU_LISTENER)\npublic void onAutoRoleSelected(EntitySelectionEvent event) {\nfinal String rolesString = event.getValues().stream()\n.map(IMentionable::getAsMention)\n.collect(Collectors.joining(\", \"));\nevent.reply(\"Your roles have been set: \" + rolesString).setEphemeral(true).queue();\n}\n</code></pre></p>"},{"location":"using-components/Selection-menus/#more-examples","title":"More examples","text":"<p>You can see more examples in the examples directory</p>"},{"location":"using-components/The-Components-API/","title":"The Components API","text":"<p>The <code>Components</code> class is the only class you need to directly use when using components (buttons / selection menus), it provides a builder for every component in order to not introduce boilerplate such as <code>Button.primary(getId(...), \"Test button\");</code>, it would instead be <code>Components.primaryButton(...).build(\"Test button\");</code></p>"},{"location":"using-components/The-Components-API/#prerequisites","title":"Prerequisites","text":"<p>You will need to set a <code>ComponentManager</code> in <code>CommandsBuilder#setComponentManager</code>, I strongly recommend that you use the <code>DefaultComponentManager</code>, unless you want to reimplement the interface.</p> <p>For the default component manager, you will need a database, you will not be able to use any database if you choose to use the <code>DefaultComponentManager</code>, PostgreSQL is what I tested the framework on, but MariaDB or H2 should work.</p> <p>The database does not need to be populated with anything, the tables are created on startup, you will only need to provide a <code>Connection</code> supplier.</p> <p>I also highly recommend you use a library capable of pooling SQL connections such as HikariCP, which will greatly reduce the time to process interactions / components</p>"},{"location":"using-components/The-Components-API/#discord-components-features","title":"Discord components features","text":"<p>There are two types of components:</p> <ul> <li>Persistent components: These are used when you may need to run a method even after your bot is restarted</li> <li>Lambda components: These are used when you need a command's context (such as captured variables) using lambdas, however this does not survive bot restarts</li> </ul> <p>Both types supports properties such as:</p> <ul> <li>One-use-ness (Component is deleted from the component manager when all conditions are met and the linked code is executed)</li> <li>Interaction constraints (Component is only usable by users which meets any of the predefined filters)</li> <li>Timeouts (Component is deleted from the component manager after a period of time)</li> </ul>"},{"location":"writing-extensions/Constructor-injection/","title":"Constructor injection","text":"<p>You might have a use case where your command needs specific objects from other instances (such as a database connection perhaps), normally you could pass them to your command constructors, but here your commands are constructed automatically, so manually doing it is not an option.</p> <p>That's why you can register constructor parameter suppliers and also instance suppliers</p>"},{"location":"writing-extensions/Constructor-injection/#how-to-use-them","title":"How to use them","text":"<p>Let's suppose you have a slash command class which looks like this:</p> <pre><code>public class SlashCtorInjectionTest extends ApplicationCommand {\nprivate final BContext context;\nprivate final Connection connection;\n\npublic SlashCtorInjectionTest(BContext context, Connection connection) {\nthis.context = context;\nthis.connection = connection;\n}\n\n@JDASlashCommand(name = \"ctorinj\")\npublic void run(GuildSlashEvent event) {\nevent.replyFormat(\"My fields are %s and %s\", context, connection).queue();\n}\n}\n</code></pre> <p>You can make these types of constructors possible by using either of the two methods described above:</p> <p>Using an instance supplier: <pre><code>Connection connection = null; //Just a test value\nCommandsBuilder.newBuilder(0L)\n.extensionsBuilder(extensionsBuilder -&gt;\nextensionsBuilder.registerInstanceSupplier(SlashCtorInjectionTest.class, context -&gt; new SlashCtorInjectionTest(context, connection))\n)\n.build(jda, \"com.freya02.bot.wiki.ctorinj.commands\");\n</code></pre></p> <p>Or using a constructor parameter supplier (preferred): <pre><code>Connection connection = null; //Just a test value\nCommandsBuilder.newBuilder(0L)\n.extensionsBuilder(extensionsBuilder -&gt;\nextensionsBuilder.registerConstructorParameter(Connection.class, ignored -&gt; connection)\n)\n.build(jda, \"com.freya02.bot.wiki.ctorinj.commands\");\n</code></pre></p>"},{"location":"writing-extensions/Constructor-injection/#notes","title":"Notes","text":"<ul> <li>The constructor parameters can be in any order</li> <li>The constructor must be accessible (public)</li> </ul>"},{"location":"writing-extensions/Creating-parameter-resolvers/","title":"Creating parameter resolvers","text":"<p>The reason why your commands with method signatures like <code>public void kick(GuildSlashEvent event, @AppOption User user, @AppOption String reason)</code> works is because there are default parameter resolvers, the default resolvers are registered automatically when ParameterResolvers is loaded. They can resolve regex command parameters / application command parameters and also button parameters</p>"},{"location":"writing-extensions/Creating-parameter-resolvers/#creating-a-new-parameterresolver","title":"Creating a new <code>ParameterResolver</code>","text":"<p>To create a new parameter resolver, you have the following steps:</p> <ul> <li>Create a new class</li> <li>Make it extend <code>ParameterResolver</code></li> <li>Use the <code>super</code> constructor to indicate the type of the resolved object</li> <li>Implement one or more of these interfaces described in <code>ParameterResolver</code></li> <li>Register the resolver with <code>ExtensionsBuilder#registerParameterResolver</code></li> </ul>"},{"location":"writing-extensions/Creating-parameter-resolvers/#example-how-to-add-a-parameterresolver","title":"Example - How to add a <code>ParameterResolver</code>","text":"<pre><code>//Create the resolver\npublic class TimestampResolver extends ParameterResolver implements SlashParameterResolver {\npublic TimestampResolver() {\nsuper(Timestamp.class);\n}\n\n@Override\npublic Object resolve(@NotNull BContext context, @NotNull SlashCommandInfo info, @NotNull CommandInteractionPayload event, @NotNull OptionMapping optionMapping) {\nfinal Matcher timestampMatcher = MARKDOWN.matcher(optionMapping.getAsString());\nif (!timestampMatcher.find()) return null; //Avoid expensive exceptions from JDA\n\nfinal String format = timestampMatcher.group(\"style\");\nfinal long time = Long.parseLong(timestampMatcher.group(\"time\"));\nreturn (format == null ? DEFAULT : fromStyle(format)).atTimestamp(time);\n}\n\n@Override\n@NotNull\npublic OptionType getOptionType() {\nreturn OptionType.STRING;\n}\n}\n</code></pre>"},{"location":"writing-extensions/Creating-parameter-resolvers/#registering-the-parameter-resolver","title":"Registering the parameter resolver","text":"<pre><code>CommandsBuilder.newBuilder()\n.extensionsBuilder(extensionsBuilder -&gt;\nextensionsBuilder.registerParameterResolver(new TimestampResolver())\n)\n.build(jda, \"com.freya02.bot.wiki.paramresolver.commands\");\n</code></pre>"},{"location":"writing-extensions/Creating-parameter-resolvers/#using-these-parameters","title":"Using these parameters","text":"<pre><code>public class SlashParamResolverTest extends ApplicationCommand {\n@JDASlashCommand(name = \"paramres\")\npublic void run(GuildSlashEvent event, @AppOption Timestamp timestamp) {\nevent.reply(\"Your timestamp as relative: \" + TimeFormat.RELATIVE.format(timestamp.getTimestamp())).queue();\n}\n}\n</code></pre>"},{"location":"writing-extensions/Field-injection/","title":"Field injection","text":"<p>You might have a use case where your command needs specific objects from other instances (such as a database connection perhaps), normally you could pass them to your command constructors, but here your commands are constructed automatically, so manually doing it is not an option.</p> <p>That's why you can register field dependencies suppliers (or use constructor injection)</p>"},{"location":"writing-extensions/Field-injection/#how-to-use-them","title":"How to use them","text":"<p>You can make these types of fields possible by using the <code>@Dependency</code> annotation:</p>"},{"location":"writing-extensions/Field-injection/#example","title":"Example","text":"<pre><code>public class SlashFieldInjectionTest extends ApplicationCommand {\n@Dependency private BContext context;\n@Dependency private Connection connection;\n\n@JDASlashCommand(name = \"fieldinj\")\npublic void run(GuildSlashEvent event) {\nevent.replyFormat(\"My fields are %s and %s\", context, connection).queue();\n}\n}\n</code></pre>"}]}