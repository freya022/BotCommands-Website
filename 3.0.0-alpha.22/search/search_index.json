{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the BotCommands wiki!","text":"<p>Have a look around the different categories on how to use this framework</p> <p>If you don't find a wiki page you need, you should check out the examples</p>"},{"location":"recipes/","title":"Recipes","text":"<p>Note</p> <p>Contributions to recipes are welcome, you can do so by contributing directly, or by suggesting (in the support server) what topics should be explained, how they should be structured, give relevant use cases/examples...</p>"},{"location":"recipes/#components","title":"Components","text":""},{"location":"recipes/#awaiting-a-component-with-coroutines","title":"Awaiting a component with coroutines","text":"<p>You can also use components without setting a handler, and instead await the event:</p> <pre><code>@Command\nclass SlashClickWaiter(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"click_waiter\", description = \"Sends a button and waits for it to be clicked\")\n    suspend fun onSlashClickWaiter(event: GuildSlashEvent) {\n        val button = buttons.primary(\"Click me\").ephemeral {\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        event.replyComponents(row(button)).await()\n\n        // Wait for the allowed user to click the button\n        val buttonEvent: ButtonEvent = button.awaitOrNull() // (1)!\n            ?: return event.hook\n                .replaceWith(\"Expired!\")\n                .awaitUnit() // (2)!\n\n        buttonEvent.editMessage(\"!\")\n            // Replace the entire message\n            .setReplace(true)\n            // Delete after 5 seconds\n            .deleteDelayed(5.seconds)\n            // Note that the coroutine will resume *after the message is deleted*\n            .await()\n    }\n}\n</code></pre> <ol> <li> <p><code>AwaitableComponent&lt;T&gt;.awaitOrNull</code> returns <code>null</code> when the component expired, useful when combined with an elvis operator, this is the equivalent of a <code>try catch</code> on <code>TimeoutCancellationException</code>. Since there is no timeout set here, the default duration is used.</p> </li> <li> <p><code>RestAction&lt;*&gt;.awaitUnit</code> is an extension to await and then return <code>Unit</code>,  which helps in common scenarios where you want to reply using an elvis operator.</p> </li> </ol>"},{"location":"using-components/","title":"Using components","text":"<p>Components provided by the framework are your usual Discord components with additional features, they can be configured to:</p> <ul> <li>Be usable once</li> <li>Have timeouts</li> <li>Have method handlers or callbacks</li> <li>Have constraints (allow list for users/roles/permissions)</li> </ul> <p>To get access to them, you can use the <code>Buttons</code> and <code>SelectMenus</code> factories, as well as <code>Components</code> to delete them manually and make groups.</p> <p>Configuring components with Java</p> <p>When configuring components, you need to use the framework's methods first,  and then use the JDA methods, and finally build.</p>"},{"location":"using-components/#enabling-components","title":"Enabling components","text":"Build-in DISpring IoC <p>Components require a database to be set up, see this wiki page for more details.</p> <p>You can then enable them with the <code>enable</code> property in the <code>components</code> configuration block.</p>  Kotlin Java <pre><code>BotCommands.create {\n    ...\n\n    components {\n        enable = true\n    }\n}        \n</code></pre> <pre><code>BotCommands.create(config -&gt; {\n    ...\n\n    config.components(components -&gt; {\n        components.enable(true);\n    });\n});\n</code></pre> <p>Components require a database to be set up, see this wiki page for more details.</p> <p>You can then enable them with the <code>botcommands.components.enable</code> property set to <code>true</code>.</p> <p>Disabling classes depending on components</p> <p>You can use <code>@RequiresComponents</code> if you want your class to be disabled when the components are not available.</p>"},{"location":"using-components/#persistent-components","title":"Persistent components","text":"<p>They are components that still work after a restart, their handlers are methods identified by their handler name, set in <code>@JDAButtonListener</code> / <code>@JDASelectMenuListener</code>.</p> <p>Persistent components have a default timeout set in <code>Components.defaultPersistentTimeout</code>, which can be changed.</p> <p>Info</p> <p>Components which expired while the bot was offline will run their timeout handlers at startup.</p> <p>Example</p>  Kotlin Java <p>In Kotlin, we can use extensions to make sure we call our component handlers in a type-safe manner. This way, you will have a compiler error if the handler and the arguments don't match, it will also allow using handlers without setting a name.</p> <p>This can only be used when the input argument types matches the handler parameter types.</p> <p>Note</p> <p>A similar <code>timeoutWith</code> function exists for timeouts.</p> <pre><code>@Command\nclass SlashPersistentClicker(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"clicker\", subcommand = \"persistent\", description = \"Creates a button you can infinitely click\")\n    suspend fun onSlashClicker(event: GuildSlashEvent) {\n        val button = createButton(event, count = 0)\n        event.replyComponents(row(button)).await()\n    }\n\n    // No need for a name if you use the type-safe \"bindWith\" extensions\n    @JDAButtonListener\n    suspend fun onCookieClick(event: ButtonEvent, @ComponentData count: Int) {\n        val button = createButton(event, count + 1)\n        event.editButton(button).await()\n    }\n\n    // Same thing here, no name required\n    @ComponentTimeoutHandler\n    fun onCookieTimeout(timeout: ComponentTimeoutData, @TimeoutData count: Int) {\n        println(\"User finished clicking $count cookies\")\n    }\n\n    private suspend fun createButton(event: Interaction, @ComponentData count: Int): Button {\n        // Create a primary-styled button\n        return buttons.primary(\"$count cookies\")\n            // Sets the emoji on the button,\n            // this can be an unicode emoji, an alias or even a custom emoji\n            .withEmoji(\"cookie\")\n\n            // Create a button that can be used even after a restart\n            .persistent {\n                // Only allow the caller to use the button\n                constraints += event.user\n\n                // Timeout and call the method after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                timeoutWith(1.days, ::onCookieTimeout, count)\n\n                // When clicked, run the onCookieClick method with the count\n                // Extension for type-safe binding, no need to type the name\n                bindWith(::onCookieClick, count)\n            }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashClickerPersistent extends ApplicationCommand {\n    // Since Java doesn't have the same method references as Kotlin,\n    // we should use a constant name, so we don't have to type it more than once.\n    private static final String COOKIE_BUTTON_NAME = \"SlashPersistentClicker: cookie\";\n\n    private final Buttons buttons;\n\n    public SlashClickerPersistent(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"clicker\", subcommand = \"persistent\", description = \"Creates a button you can infinitely click\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final Button button = createButton(event, 0);\n        event.replyComponents(ActionRow.of(button)).queue();\n    }\n\n    // The name should be unique,\n    // I recommend naming the handler \"[ClassName]: [purpose]\"\n    // And the name would be \"on[purpose]Click\"\n    @JDAButtonListener(COOKIE_BUTTON_NAME)\n    public void onCookieClick(ButtonEvent event, @ComponentData int count) {\n        final Button newButton = createButton(event, count + 1);\n        event.editButton(newButton).queue();\n    }\n\n    // Same thing here, names don't collide with other types of listener\n    @ComponentTimeoutHandler(COOKIE_BUTTON_NAME)\n    public void onCookieTimeout(ComponentTimeoutData timeout, @TimeoutData String count) {\n        System.out.println(\"User finished clicking \" + count + \" cookies\");\n    }\n\n    private Button createButton(Interaction event, int count) {\n        // Create a primary-styled button\n        return buttons.primary(count + \" cookies\")\n                // Sets the emoji on the button,\n                // this can be an unicode emoji, an alias or even a custom emoji\n                .withEmoji(\"cookie\")\n\n                // Create a button that can be used even after a restart\n                .persistent()\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Timeout and call the method after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                .timeout(Duration.ofDays(1), COOKIE_BUTTON_NAME, count)\n\n                // When clicked, run the onCookieClick method with the count\n                .bindTo(COOKIE_BUTTON_NAME, count)\n                .build();\n    }\n}\n</code></pre>"},{"location":"using-components/#ephemeral-components","title":"Ephemeral components","text":"<p>They are components which get invalidated after a restart, meaning they can no longer be used, their handlers are callbacks, which can also have a timeout set, and also use callbacks.</p> <p>Info</p> <p>\"Invalidated\" means that they are deleted from the database, but not necessarily from the message.</p> <p>Ephemeral components have a default timeout set in <code>Components.defaultEphemeralTimeout</code>, which can be changed.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashEphemeralClicker(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"clicker\", subcommand = \"ephemeral\", description = \"Creates a button you can click until the bot restarts or 15 minutes later\")\n    suspend fun onSlashClicker(event: GuildSlashEvent) {\n        val button = createButton(event, count = 0)\n        event.replyComponents(row(button)).await()\n    }\n\n    private suspend fun createButton(event: IDeferrableCallback, count: Int): Button {\n        // Create a primary-styled button\n        return buttons.primary(\"$count cookies\")\n            // Sets the emoji on the button,\n            // this can be an unicode emoji, an alias or even a custom emoji\n            .withEmoji(\"cookie\")\n\n            // Create a button that can be used until the bot restarts\n            .ephemeral {\n                // Only allow the caller to use the button\n                constraints += event.user\n\n                // Run this callback 15 minutes after the button has been created\n                // The timeout gets cancelled if the button is invalidated\n                timeout(15.minutes) {\n                    if (!event.hook.isExpired) {\n                        event.hook.retrieveOriginal()\n                            .map { it.components.asDisabled() }\n                            .flatMap { event.hook.editOriginalComponents(it) }\n                            .queue()\n                        event.hook.sendMessage(\"You clicked $count cookies!\").setEphemeral(true).queue()\n                    } else {\n                        println(\"User finished clicking $count cookies\")\n                    }\n                }\n\n                // When clicked, run this callback\n                bindTo { buttonEvent -&gt;\n                    val newButton = createButton(buttonEvent, count + 1)\n                    buttonEvent.editButton(newButton).await()\n                }\n            }\n    }\n}\n</code></pre> <p>You can also use components without setting a handler, and instead await the event:</p> <pre><code>@Command\nclass SlashEphemeralAwaitingClicker(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"clicker\", subcommand = \"ephemeral_await\", description = \"Creates a button you can click until the bot restarts or 15 minutes later\")\n    suspend fun onSlashClicker(event: GuildSlashEvent) {\n        val button = createButton(event, count = 0)\n        event.replyComponents(row(button)).await()\n\n        var count = 0\n        // When the 15 minutes expire,\n        // the loop is stopped due to a TimeoutCancellationException (see 'await' on the button).\n        try {\n            while (true) {\n                // Wait for the button to be clicked and edit it with a new label\n                // you can keep the same button id as we keep awaiting the same one\n                val buttonEvent = button.await()\n                buttonEvent.editButton(button.withLabel(\"${++count} cookies\")).await()\n            }\n        } catch (_: TimeoutCancellationException) { }\n\n        // Try to disable components if the interaction is still usable\n        if (!event.hook.isExpired) {\n            event.hook.retrieveOriginal()\n                .map { it.components.asDisabled() }\n                .flatMap { event.hook.editOriginalComponents(it) }\n                .queue()\n            event.hook.sendMessage(\"You clicked $count cookies!\").setEphemeral(true).queue()\n        } else {\n            println(\"User finished clicking $count cookies\")\n        }\n    }\n\n    private suspend fun createButton(event: Interaction, count: Int): Button {\n        // Create a primary-styled button\n        return buttons.primary(\"$count cookies\")\n            // Sets the emoji on the button,\n            // this can be an unicode emoji, an alias or even a custom emoji\n            .withEmoji(\"cookie\")\n\n            // Create a button that can be used until the bot restarts\n            .ephemeral {\n                // Only allow the caller to use the button\n                constraints += event.user\n\n                // Invalidate the button after 15 minutes, cancelling all coroutines awaiting on the button\n                timeout(15.minutes)\n            }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashClickerEphemeral extends ApplicationCommand {\n    private final Buttons buttons;\n\n    public SlashClickerEphemeral(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"clicker\", subcommand = \"ephemeral\", description = \"Creates a button you can click until the bot restarts\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final Button button = createButton(event, 0);\n        event.replyComponents(ActionRow.of(button)).queue();\n    }\n\n    private Button createButton(Interaction event, int count) {\n        // Create a primary-styled button\n        return buttons.primary(count + \" cookies\")\n                // Sets the emoji on the button,\n                // this can be an unicode emoji, an alias or even a custom emoji\n                .withEmoji(\"cookie\")\n\n                // Create a button that can be used until the bot restarts\n                .ephemeral()\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this callback 15 minutes after the button has been created\n                // The timeout gets cancelled if the button is invalidated\n                .timeout(Duration.ofMinutes(15), () -&gt; {\n                    System.out.println(\"User finished clicking \" + count + \" cookies\");\n                })\n\n                // When clicked, run this callback\n                .bindTo(buttonEvent -&gt; {\n                    final Button newButton = createButton(buttonEvent, count + 1);\n                    buttonEvent.editButton(newButton).queue();\n                })\n                .build();\n    }\n}\n</code></pre>"},{"location":"using-components/#component-groups","title":"Component groups","text":"<p>Component groups can be created in any component factory, and allow you to configure one timeout for all components.</p> <p>Also, when one of them gets invalidated (after being used with <code>singleUse = true</code>), the entire group gets invalidated.</p> <p>For example, this can be useful when the user needs to use a single component, once.</p> <p>Ephemeral components in groups</p> <p>If you put ephemeral components in your group, you must disable the timeout with <code>noTimeout()</code>.</p> <p>The timeout works similarly to components, except the annotated handler is a <code>@GroupTimeoutHandler</code>.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashClickGroup(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"click_group\", description = \"Sends two buttons and waits for any of them to be clicked\")\n    suspend fun onSlashClickGroup(event: GuildSlashEvent) {\n        val firstButton = buttons.primary(\"1\").ephemeral {\n            // Disable the timeout so we can use a group timeout\n            noTimeout()\n\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        val secondButton = buttons.primary(\"2\").ephemeral {\n            // Disable the timeout so we can use a group timeout\n            noTimeout()\n\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        // Construct our group, make it expire after 1 minute\n        val group = buttons.group(firstButton, secondButton).ephemeral {\n            timeout(1.minutes)\n        }\n        event.replyComponents(row(firstButton, secondButton)).await()\n\n        // Wait for the allowed user to click one of the buttons\n        val buttonEvent = group.awaitAnyOrNull&lt;ButtonEvent&gt;()\n            ?: return event.hook\n                .replaceWith(\"Expired!\")\n                .awaitUnit()\n\n        // Disable the other button\n        buttonEvent.editButton(buttonEvent.button.asDisabled()).await()\n        buttonEvent.hook.editOriginal(\"Try clicking the other button, you can't :^)\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashClickGroup extends ApplicationCommand {\n    // Since Java doesn't have the same method references as Kotlin,\n    // we should use a constant name, so we don't have to type it more than once.\n    private static final String COOKIE_BUTTON_NAME = \"SlashPersistentClicker: cookie\";\n\n    private final Buttons buttons;\n\n    public SlashClickGroup(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"click_group\", description = \"Sends two buttons and waits for any of them to be clicked\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final var firstButton = buttons.primary(\"1\")\n                .ephemeral()\n                // Disable the timeout so we can use a group timeout\n                .noTimeout()\n\n                // Make it so this button is only usable once\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this method when the button is clicked\n                .bindTo(this::onButtonClick)\n                .build();\n\n        final var secondButton = buttons.primary(\"2\")\n                .ephemeral()\n                // Disable the timeout so we can use a group timeout\n                .noTimeout()\n\n                // Make it so this button is only usable once\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this method when the button is clicked\n                .bindTo(this::onButtonClick)\n                .build();\n        // Construct our group, make it expire after 1 minute\n        buttons.group(firstButton, secondButton)\n                .ephemeral()\n                .timeout(Duration.ofMinutes(1), () -&gt; onButtonTimeout(event))\n                .build();\n\n        event.replyComponents(ActionRow.of(firstButton, secondButton)).queue();\n    }\n\n    private void onButtonClick(ButtonEvent event) {\n        event.editButton(event.getButton().asDisabled()).queue();\n        event.getHook().editOriginal(\"Try clicking the other button, you can't :^)\").queue();\n    }\n\n    private void onButtonTimeout(GuildSlashEvent event) {\n        event.getHook()\n                .editOriginal(\"Expired!\")\n                .setReplace(true)\n                .queue();\n    }\n}\n</code></pre>"},{"location":"using-components/#reset-timeout-on-use","title":"Reset timeout on use","text":"<p>The <code>resetTimeoutOnUse</code> lets you reset the timeout each time the button is clicked. The timeout is only reset if the button was actually used, it will not be reset if unauthorized users use it.</p>"},{"location":"using-components/#deleting-components","title":"Deleting components","text":"<p>Here are some tips on how to delete components:</p> <ul> <li>Most likely, you have the message (from a <code>ButtonEvent</code> for example) and you want to delete the buttons from the message and invalidate them, in this case you should use <code>deleteRows</code>.</li> <li> <p>In stateful interactions, where components can be reused, you might sometimes want to store the IDs of the components, to then invalidate them when the interaction expires.</p> <p>Example</p> <p>The built-in paginators stores all the <code>int</code> IDs of the components used in paginators, as they cannot be deleted on each page change, as the user might reuse a component they made themselves. Storing them this way is more efficient and allows deletion when the paginator expires, using <code>deleteRows</code>.</p> </li> <li> <p>In other, rare cases, you have the component instances (not the JDA ones), for which you can use <code>deleteComponents</code></p> </li> </ul>"},{"location":"using-components/#filtering","title":"Filtering","text":"<p>Components also support filtering, you can use <code>addFilter</code> with either the filter type, or the filter instance directly.</p> <p>Passing custom filter instances</p> <p>You cannot pass filters that cannot be obtained via dependency injection, this includes composite filters (using <code>and</code> / <code>or</code>),  see <code>ComponentInteractionFilter</code> for more details</p>"},{"location":"using-components/#creating-a-filter","title":"Creating a filter","text":"<p>Creating a filter can be done by implementing <code>ComponentInteractionFilter</code> and registering it as a service,  they run when a component is about to be executed.</p> <p>Lets create a filter that allows the component to be usable in a predefined one channel:</p> <p>Note</p> <p>Your filter needs to not be global in order to be used on specific components.</p>  Kotlin Java <pre><code>@BService\nclass GeneralChannelFilter : ComponentInteractionFilter&lt;String/*(1)!*/&gt; {\n    private val channelId = 722891685755093076\n\n    // So we can apply this filter on specific components\n    override val global: Boolean = false\n\n    override suspend fun checkSuspend(\n        event: GenericComponentInteractionCreateEvent,\n        handlerName: String?\n    ): String? {\n        if (event.channelIdLong == channelId)\n            return \"This button can only be used in &lt;#$channelId&gt;\"\n        return null\n    }\n}\n</code></pre> <ol> <li>This is the return type of the filter, this will be passed as <code>userData</code> in your rejection handler.</li> </ol> <pre><code>@BService\npublic class GeneralChannelFilter implements ComponentInteractionFilter&lt;String/*(1)!*/&gt; {\n    private static final long CHANNEL_ID = 722891685755093076L;\n\n    @Override\n    public boolean getGlobal() {\n        // So we can apply this filter on specific components\n        return false;\n    }\n\n    @Nullable\n    @Override\n    public String check(@NotNull GenericComponentInteractionCreateEvent event,\n                        @Nullable String handlerName) {\n        if (event.getChannelIdLong() == CHANNEL_ID)\n            return \"This button can only be used in &lt;#\" + CHANNEL_ID + \"&gt;\";\n        return null;\n    }\n}\n</code></pre> <ol> <li>This is the return type of the filter, this will be passed as <code>userData</code> in your rejection handler.</li> </ol>"},{"location":"using-components/#creating-a-rejection-handler","title":"Creating a rejection handler","text":"<p>You must then create a single rejection handler for all your filters,  it runs when one of your filters fails.</p> <p>Note</p> <p>All of your filters must have the same return type as the rejection handler (the generic you set on the interface).</p>  Kotlin Java <pre><code>@BService\nclass ComponentRejectionHandler : ComponentInteractionRejectionHandler&lt;String/*(1)!*/&gt; {\n    override suspend fun handleSuspend(\n        event: GenericComponentInteractionCreateEvent,\n        handlerName: String?,\n        userData: String\n    ) {\n        event.reply_(userData, ephemeral = true).await()\n    }\n}\n</code></pre> <ol> <li>This is what was returned by one of your filters, this will be passed as <code>userData</code>.</li> </ol> <pre><code>@BService\npublic class ComponentRejectionHandler implements ComponentInteractionRejectionHandler&lt;String/*(1)!*/&gt; {\n    @Override\n    public void handle(@NotNull GenericComponentInteractionCreateEvent event,\n                       @Nullable String handlerName,\n                       @NotNull String userData) {\n        event.reply(userData).setEphemeral(true).queue();\n    }\n}\n</code></pre> <ol> <li>This is what was returned by one of your filters, this will be passed as <code>userData</code>.</li> </ol>"},{"location":"using-components/#using-an-existing-filter","title":"Using an existing filter","text":"<p>Now that your filter has been created, you can reference it in your component.</p>  Kotlin Java <pre><code>buttons.primary(\"Can't click me\").ephemeral {\n    filters += filter&lt;GeneralChannelFilter&gt;()\n}\n</code></pre> <pre><code>buttons.primary(\"Can't click me\")\n    .ephemeral()\n    .addFilter(GeneralChannelFilter.class)\n    .build()\n</code></pre>"},{"location":"using-components/#rate-limiting","title":"Rate limiting","text":"<p>Just like application commands, components can be rate limited. However, you will need to help the library differentiate components from each other (unlike commands which are differentiated by their names).</p> <p>Learn how to create a rate limiter with \"Defining a rate limit\"</p> <p>You will first need to create a <code>ComponentRateLimitReference</code>, you can do that with <code>createRateLimitReference</code>, present in any component factory (<code>Components</code>, <code>Buttons</code>, <code>SelectMenus</code>).</p> <p>The <code>group</code> associated with the <code>discriminator</code> will need to be unique, as to differentiate components (referenced by <code>discriminator</code>) using the same rate limiter (referenced by <code>group</code>).</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashComponentRateLimit(private val buttons: Buttons) : ApplicationCommand() {\n    // This is to prevent an unnecessary load on startup, emojis are slow\n    private val arrowUp: UnicodeEmoji by lazyUnicodeEmoji { Emojis.UP_ARROW }\n    private val arrowDown: UnicodeEmoji by lazyUnicodeEmoji { Emojis.DOWN_ARROW }\n\n    // The combination of the group and discriminator must be unique\n    private val upvoteRateLimitReference = buttons.createRateLimitReference(\n        // The name of the rate limiter\n        group = WikiRateLimitProvider.RATE_LIMIT_GROUP,\n        // The \"discriminator\" for this component,\n        // this is important as this differentiates a component from others\n        discriminator = \"upvote\"\n    )\n    private val downvoteRateLimitReference = buttons.createRateLimitReference(\n        group = WikiRateLimitProvider.RATE_LIMIT_GROUP,\n        discriminator = \"downvote\"\n    )\n\n    @JDASlashCommand(name = \"component_rate_limit\")\n    suspend fun onSlashComponentRateLimit(event: GuildSlashEvent) {\n        val upvoteButton = buttons.success(\"Upvote\", arrowUp).ephemeral {\n            rateLimitReference(upvoteRateLimitReference)\n\n            bindTo { buttonEvent -&gt;\n                buttonEvent.reply(\"Your vote has been taken into account\").setEphemeral(true).queue()\n            }\n        }\n\n        val downvoteButton = buttons.danger(\"Downvote\", arrowDown).ephemeral {\n            rateLimitReference(downvoteRateLimitReference)\n\n            bindTo { buttonEvent -&gt;\n                buttonEvent.reply(\"Your anger has been taken into account\").setEphemeral(true).queue()\n            }\n        }\n\n        event.reply(\"[Insert controversial sentence]\")\n            .addActionRow(upvoteButton, downvoteButton)\n            .await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashComponentRateLimit extends ApplicationCommand {\n    // This is to prevent an unnecessary load on startup, emojis are slow\n    private static class Emojis {\n        static final UnicodeEmoji arrowUp = EmojiUtils.resolveJDAEmoji(\"arrow_up\");\n        static final UnicodeEmoji arrowDown = EmojiUtils.resolveJDAEmoji(\"arrow_down\");\n    }\n\n    private final Buttons buttons;\n    private final ComponentRateLimitReference upvoteRateLimitReference;\n    private final ComponentRateLimitReference downvoteRateLimitReference;\n\n    public SlashComponentRateLimit(Buttons buttons) {\n        this.buttons = buttons;\n        // The combination of the group and discriminator must be unique\n        this.upvoteRateLimitReference = buttons.createRateLimitReference(\n                // The name of the rate limiter\n                WikiRateLimitProvider.RATE_LIMIT_GROUP,\n                // The \"discriminator\" for this component,\n                // this is important as this differentiates a component from others\n                \"upvote\"\n        );\n        this.downvoteRateLimitReference = buttons.createRateLimitReference(WikiRateLimitProvider.RATE_LIMIT_GROUP, \"downvote\");\n    }\n\n    @JDASlashCommand(name = \"component_rate_limit\")\n    public void onSlashComponentRateLimit(GuildSlashEvent event) {\n        final var upvoteButton = buttons.success(\"Upvote\", Emojis.arrowUp)\n                .ephemeral()\n                .rateLimitReference(upvoteRateLimitReference)\n                .bindTo(buttonEvent -&gt; {\n                    buttonEvent.reply(\"Your vote has been taken into account\").setEphemeral(true).queue();\n                })\n                .build();\n\n        final var downvoteButton = buttons.danger(\"Downvote\", Emojis.arrowDown)\n                .ephemeral()\n                .rateLimitReference(downvoteRateLimitReference)\n                .bindTo(buttonEvent -&gt; {\n                    buttonEvent.reply(\"Your anger has been taken into account\").setEphemeral(true).queue();\n                })\n                .build();\n\n        event.reply(\"[Insert controversial sentence]\")\n                .addActionRow(upvoteButton, downvoteButton)\n                .queue();\n    }\n}\n</code></pre>"},{"location":"setup/getting-started/","title":"Starting from scratch","text":"<p>Start by creating a project either using Maven or Gradle, it must run on Java 17+, I recommend using Java 21.</p> <p>Creating a new Maven project</p> <p>When creating a Maven project in IntelliJ, do not choose <code>Maven Archetype</code> in <code>Generators</code>, you must use <code>New Project</code>.</p>"},{"location":"setup/getting-started/#adding-the-dependencies","title":"Adding the dependencies","text":"<p>The only strictly necessary dependencies are the framework and JDA:</p> <p> </p> <p>Omit the <code>v</code> prefix from the version, e.g. <code>5.0.0-beta.18</code>.</p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n        &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n        &lt;version&gt;JDA_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.github.freya022&lt;/groupId&gt;\n        &lt;artifactId&gt;BotCommands&lt;/artifactId&gt;\n        &lt;version&gt;BC_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"net.dv8tion:JDA:JDA_VERSION\")\n    implementation(\"io.github.freya022:BotCommands:BC_VERSION\")\n}\n</code></pre>"},{"location":"setup/getting-started/#adding-logging","title":"Adding logging","text":"<p>Any SLF4J compatible logger should work; I recommend logback, which you can learn more here.</p>"},{"location":"setup/getting-started/#creating-a-config-service","title":"Creating a config service","text":"<p>Create a small <code>Config</code> service, it can be a simple object with the properties you need,  this will be useful when running your bot.</p> Example  Kotlin Java <pre><code>class Config(val token: String, val ownerIds: List&lt;Long&gt;) {\n    companion object {\n        // Makes a service factory out of this property getter\n        @get:BService\n        val instance by lazy {\n            // Load your config\n        }\n    }\n}\n</code></pre> <pre><code>public class Config {\n    private static Config INSTANCE = null;\n\n    private String token;\n    private List&lt;Long&gt; ownerIds;\n\n    public String getToken() { return token; }\n    public List&lt;Long&gt; getOwnerIds() { return ownerIds; }\n\n    @BService // Makes this method a service factory that outputs Config objects\n    public static Config getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = // Load your config\n        }\n\n        return INSTANCE;\n    }\n}\n</code></pre> <p>Info</p> <p>You can refer to the Dependency Injection page for more details</p>"},{"location":"setup/getting-started/#creating-the-main-class","title":"Creating the main class","text":"<p>As we've used a singleton pattern for your <code>Config</code> class, we can get the same instance anywhere,  and still be able to get it as a service.</p> Built-in DISpring IoC <p>All you need to do to start the framework is <code>BotCommands#create</code>:</p>  Kotlin Java Main.kt - Main function<pre><code>val config = Config.instance\n\nBotCommands.create {\n    // Optionally set the owner IDs if they differ from the owners in the Discord dashboard\n    // addPredefinedOwners(config.ownerIds)\n\n    // Add the base package of the application\n    // All services and commands inside will be loaded\n    addSearchPath(\"io.github.name.bot\")\n\n    textCommands {\n        usePingAsPrefix = true // The bot will respond to his mention/ping\n    }\n}    \n</code></pre> Main.java - Main method<pre><code>final var config = Config.getInstance();\n\nBotCommands.create(builder -&gt; {\n    // Optionally set the owner IDs if they differ from the owners in the Discord dashboard\n    // builder.addPredefinedOwners(config.getOwnerIds());\n\n    // Add the base package of the application\n    // All services and commands inside will be loaded\n    builder.addSearchPath(\"io.github.name.bot\");\n\n    builder.textCommands(textCommands -&gt; {\n        textCommands.usePingAsPrefix(true);\n    });\n});\n</code></pre> <p>The framework also supports Spring IoC, add the library, add the package of your application with the <code>scanBasePackages</code> value of your <code>@SpringBootApplication</code>, and voil\u00e0.</p> <p>Note</p> <p>You can always disable it by adding <code>BotCommandsAutoConfiguration</code> to the <code>exclude</code> value of your <code>@SpringBootApplication</code>.</p> <p>Configuration of the framework is then done either by using application properties (with the prefix being either <code>botcommands</code> or <code>jda</code>), or by implementing configurers, see the <code>BConfigurer</code> inheritors.</p> <p>Tip</p> <p>You can also use the Spring developer tools to speed up your development cycle, a few options can be configured with <code>jda.devtools.*</code> properties.</p> Kotlin - Using a custom <code>CoroutineEventManager</code> <p>I recommend creating a custom <code>CoroutineEventManager</code>, that way you can configure the amount of threads or their names, which may be convenient in logs.</p> <p>You can do so by implementing a <code>ICoroutineEventManagerSupplier</code> service,  with the help of <code>namedDefaultScope</code>: <pre><code>@BService\nclass CoroutineEventManagerSupplier : ICoroutineEventManagerSupplier {\n    override fun get(): CoroutineEventManager {\n        val scope = namedDefaultScope(\"WikiBot Coroutine\", corePoolSize = 4)\n        return CoroutineEventManager(scope)\n    }\n}\n</code></pre></p> <p>Warning</p> <p>JDA must be created after the framework is built, as the framework listens to JDA events and must not skip any of these, you will need to make a service extending <code>JDAService</code>.</p>"},{"location":"setup/getting-started/#creating-a-jdaservice","title":"Creating a <code>JDAService</code>","text":"<p>Now you've been able to start the framework, all your services (such as <code>Config</code> for the moment) should be loaded,  but you must now have a way to start JDA, implementing <code>JDAService</code> will let you start the bot in a convenient place.</p> <p>Implementing <code>JDAService</code> guarantees that your bot will connect at the right time, and provides a way for the framework to check missing intents and missing cache flags before your bot even starts.</p> <p>Spring properties</p> <p>If you use Spring, you will need to put gateway intents and cache flags in your environment. You will then be able to set your gateway intents and cache flags using the values provided by <code>JDAConfiguration</code>.</p>  Kotlin Java <pre><code>@BService\nclass Bot(private val config: Config) : JDAService() {\n    // If you use Spring, you can set the properties below to the values provided by JDAConfiguration\n    override val intents: Set&lt;GatewayIntent&gt; = defaultIntents(/* _Additional_ intents */ GatewayIntent.GUILD_VOICE_STATES)\n\n    override val cacheFlags: Set&lt;CacheFlag&gt; = setOf(/* _Additional_ cache flags */ CacheFlag.VOICE_STATE)\n\n    override fun createJDA(event: BReadyEvent, eventManager: IEventManager) {\n        // This uses JDABuilder#createLight, with the intents and the additional cache flags set above\n        // It also sets the EventManager and a special rate limiter\n        light(\n            config.token,\n            activity = Activity.customStatus(\"In Kotlin with \u2764\ufe0f\")\n        ) {\n            // Other configs\n        }\n    }\n}\n</code></pre> <pre><code>@BService\npublic class Bot extends JDAService {\n    private final Config config;\n\n    public Bot(Config config) {\n        this.config = config;\n    }\n\n    // If you use Spring, you can return values provided by JDAConfiguration in the getters below\n    @NotNull\n    @Override\n    public Set&lt;CacheFlag&gt; getCacheFlags() {\n        return Set.of(/* _Additional_ cache flags */);\n    }\n\n    @NotNull\n    @Override\n    public Set&lt;GatewayIntent&gt; getIntents() {\n        return defaultIntents(/* _Additional_ intents */);\n    }\n\n    @Override\n    public void createJDA(@NotNull BReadyEvent event, @NotNull IEventManager eventManager) {\n        // This uses JDABuilder#createLight, with the intents and the additional cache flags set above\n        // It also sets the EventManager and a special rate limiter\n        createLight(config.getToken())\n                .setActivity(Activity.customStatus(\"In Java with \u2764\ufe0f\"))\n                .build();\n    }\n}\n</code></pre> <p>You can now run your bot! Assuming you have done your config class and provided at least the token and owner IDs,  you should be able to run the help command, by mentioning your bot <code>@YourBot help</code>.</p> <p>Tip</p> <p>If necessary, you can retrieve a <code>JDA</code> instance once <code>createJDA</code> has been called,  I recommend listening to <code>InjectedJDAEvent</code>, but you can also get one later, using <code>BContext#jda</code>.</p>"},{"location":"setup/getting-started/#optional-add-stacktrace-decoroutinator","title":"Optional - Add <code>stacktrace-decoroutinator</code>","text":"<p>I recommend adding <code>stacktrace-decoroutinator</code>,  which will help you get clearer stacktrace when using Kotlin coroutines.</p> <p>Note</p> <p>Java users also benefit from it as it may help debug framework issues.</p> <p></p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;dev.reformator.stacktracedecoroutinator&lt;/groupId&gt;\n        &lt;artifactId&gt;stacktrace-decoroutinator-jvm&lt;/artifactId&gt;\n        &lt;version&gt;SD_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"dev.reformator.stacktracedecoroutinator:stacktrace-decoroutinator-jvm:SD_VERSION\")\n}\n</code></pre> <p>Finally, load it on the first lines of your main program:</p>  Kotlin Java <pre><code>// stacktrace-decoroutinator has issues when reloading with hotswap agent\nif (\"-XX:+AllowEnhancedClassRedefinition\" in ManagementFactory.getRuntimeMXBean().inputArguments) {\n    logger.info { \"Skipping stacktrace-decoroutinator as enhanced hotswap is active\" }\n} else if (\"--no-decoroutinator\" in args) {\n    logger.info { \"Skipping stacktrace-decoroutinator as --no-decoroutinator is specified\" }\n} else {\n    DecoroutinatorRuntime.load()\n}\n</code></pre> <p>Warning</p> <p><code>stacktrace-decoroutinator</code> must be loaded before any coroutine code is loaded,  including suspending main functions <code>suspend fun main() { ... }</code>.</p> <pre><code>// stacktrace-decoroutinator has issues when reloading with hotswap agent\nif (ManagementFactory.getRuntimeMXBean().getInputArguments().contains(\"-XX:+AllowEnhancedClassRedefinition\")) {\n    logger.info(\"Skipping stacktrace-decoroutinator as enhanced hotswap is active\");\n} else if (Arrays.asList(args).contains(\"--no-decoroutinator\")) {\n    logger.info(\"Skipping stacktrace-decoroutinator as --no-decoroutinator is specified\");\n} else {\n    DecoroutinatorRuntime.INSTANCE.load();\n}\n</code></pre>"},{"location":"setup/getting-started/#creating-a-runnable-jar","title":"Creating a runnable JAR","text":"MavenKotlin Gradle <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.5.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;shade&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;transformers&gt;\n                    &lt;transformer\n                            implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt;\n                        &lt;mainClass&gt;io.github.name.bot.Main&lt;/mainClass&gt; &lt;!-- TODO change here --&gt;\n                    &lt;/transformer&gt;\n                    &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/&gt;\n                &lt;/transformers&gt;\n\n                &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;\n                &lt;finalName&gt;${artifactId}&lt;/finalName&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <pre><code>plugins {\n    ...\n    id(\"com.github.johnrengelman.shadow\") version \"7.1.2\"\n}\n\napplication.mainClass.set(\"io.github.name.bot.Main\")    //TODO change here\n\ntasks.withType&lt;ShadowJar&gt; {\n    mergeServiceFiles() // Fixes Java's service loading, which is used by Flyway\n    archiveFileName.set(\"your-project-name.jar\")        //TODO change here\n}\n</code></pre> <p>While you can run the main class in your IDE during development, you can create a JAR with all the dependencies by pressing Ctrl twice in IntelliJ, then running:</p> MavenKotlin Gradle <pre><code>mvn package\n</code></pre> <pre><code>gradle shadowJar\n</code></pre>"},{"location":"setup/getting-started/#other-resources","title":"Other resources","text":"<p>Take a look at other wiki pages, such as Dependency injection,  Creating slash command and Using components.</p>"},{"location":"setup/getting-started/#examples","title":"Examples","text":"<p>You can find examples covering parts of the framework here.</p>"},{"location":"setup/getting-started/#getting-help","title":"Getting help","text":"<p>Don't hesitate to join the support server if you have any question!</p>"},{"location":"setup/logging/","title":"Logging","text":"<p>Add a logger with the following dependencies:</p> <p> </p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n        &lt;version&gt;SLF4J_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n        &lt;version&gt;LOGBACK_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"org.slf4j:slf4j-api:SLF4J_VERSION\")\n    implementation(\"ch.qos.logback:logback-classic:LOGBACK_VERSION\")\n}\n</code></pre> <p>Here are the logback configs I recommend using:</p> Dev configProd config <p>I would recommend putting it in your project, in a folder containing your config files, and load it as such:</p> <p>Danger</p> <p>Just like any sensitive data, make sure to add the folder to your .gitignore,  as it will contain much more than just the logback config.</p> <p>However, you can provide a template for contributors/other users.</p>  Kotlin Java <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.absolutePathString())\n</code></pre> <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.toAbsolutePath().toString());\n</code></pre> logback-test.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration scan=\"true\"&gt; &lt;!-- Reloads every minute --&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- JDA --&gt;\n    &lt;logger name=\"net.dv8tion.jda\" level=\"info\"/&gt;\n\n    &lt;!-- HikariCP --&gt;\n    &lt;logger name=\"com.zaxxer.hikari\" level=\"info\"/&gt;\n\n    &lt;!-- Flyway --&gt;\n    &lt;logger name=\"org.flywaydb\" level=\"warn\"/&gt;\n\n    &lt;!-- BotCommands --&gt;\n    &lt;logger name=\"io.github.freya022.botcommands\" level=\"debug\"/&gt;\n\n    &lt;!-- Other logs --&gt;\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>I would recommend putting it in a folder next to the bot's JAR, and load it as such:</p>  Kotlin Java <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.absolutePathString())\n</code></pre> <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.toAbsolutePath().toString());\n</code></pre> logback.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration scan=\"true\"&gt; &lt;!-- Reloads every minute --&gt;\n    &lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt;\n\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;file&gt;logs/latest.log&lt;/file&gt;\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n            &lt;!-- daily rollover --&gt;\n            &lt;fileNamePattern&gt;logs/logs-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;\n\n            &lt;!-- keep 90 days worth of history capped at 3GB total size --&gt;\n            &lt;maxHistory&gt;90&lt;/maxHistory&gt;\n            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;\n        &lt;/rollingPolicy&gt;\n\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %-26.-26thread %-36.-36class{36} #%-24.-24method{24} L%-5.-5line %-20.-20logger{0} %-6level %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- JDA --&gt;\n    &lt;logger name=\"net.dv8tion.jda\" level=\"info\"/&gt;\n\n    &lt;!-- HikariCP --&gt;\n    &lt;logger name=\"com.zaxxer.hikari\" level=\"info\"/&gt;\n\n    &lt;!-- Flyway --&gt;\n    &lt;logger name=\"org.flywaydb\" level=\"info\"/&gt;\n\n    &lt;!-- BotCommands --&gt;\n    &lt;logger name=\"io.github.freya022.botcommands\" level=\"debug\"/&gt;\n\n    &lt;!-- Other logs --&gt;\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n        &lt;appender-ref ref=\"FILE\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"using-botcommands/app-emojis/","title":"Using application emojis","text":"<p>Long gone are the days when you had to add emojis to your own guilds, you can now add up to 2000 emojis on your application.</p> <p>While you can add them manually in your dashboard, they are:</p> <ul> <li>Not very practical</li> <li>Requires you to hardcode them (unless you fetch them yourself, but that's even more effort)</li> <li>Can only be used for one application, making it annoying when you switch from a test bot to your production bot.</li> </ul> <p>Which is why you can let the framework upload them for you! It will upload them after JDA logs in, but before it comes online.</p>"},{"location":"using-botcommands/app-emojis/#making-an-application-emoji-container","title":"Making an application emoji container","text":"<p>The first step is to create a class that will hold your application emojis, you will need to annotate it with <code>@AppEmojiContainer</code>,  which tells the library to load all <code>ApplicationEmoji</code> fields inside it.</p> <p>This will search emojis in the <code>/emojis</code> folder by default, but you can change it in the annotation. </p>"},{"location":"using-botcommands/app-emojis/#registeringretrieving-application-emojis","title":"Registering/retrieving application emojis","text":""},{"location":"using-botcommands/app-emojis/#eager-retrieval","title":"Eager retrieval","text":"Kotlin Java <p>You can use delegated properties on <code>AppEmojisRegistry</code> to get an application emoji from your property's name, for example:</p> <pre><code>@AppEmojiContainer\nobject AppEmojis {\n    @AppEmoji(emojiName = \"kotlin_eager\") // Optionally use this if you want to change defaults\n    val kotlin: ApplicationEmoji by AppEmojisRegistry\n}\n</code></pre> <p>You can use <code>AppEmojisRegistry.get</code>, pass it the name of your field, for example:</p> <pre><code>@AppEmojiContainer\npublic class AppEmojis {\n    @AppEmoji(emojiName = \"java_eager\") // Optionally use this if you want to change defaults\n    public static final ApplicationEmoji java = AppEmojisRegistry.get(\"java\");\n}\n</code></pre> <p>Warning</p> <p>You must not initialize the class before the emojis are loaded, in other words, you can only access your fields/properties once they have been retrieved. You typically don't need to do anything but to use the emojis when they are actually needed.</p>"},{"location":"using-botcommands/app-emojis/#lazy-retrieval-kotlin-only","title":"Lazy retrieval (Kotlin only)","text":"<p>Similar to eager retrieval, you can use delegated properties on <code>AppEmojisRegistry.lazy</code>, for example:</p> <pre><code>@AppEmojiContainer\nobject LazyAppEmojis {\n    val kotlin: ApplicationEmoji by AppEmojisRegistry.lazy(::kotlin, /* Overrides default values */ emojiName = \"kotlin_lazy\")\n}\n</code></pre> <p>As always, you cannot use the emoji before it is loaded, however, loading the <code>object</code> itself is fine.</p>"},{"location":"using-botcommands/database/","title":"Using a database","text":"<p>The framework provides several JDBC abstractions, statement logging, reporting long transactions and officially supports PostgreSQL and H2 (in PostgreSQL compatibility mode).</p> <p>Info</p> <p>Some features requires a database, such as components and paginators.</p>"},{"location":"using-botcommands/database/#creating-a-connectionsupplier","title":"Creating a <code>ConnectionSupplier</code>","text":"<p>A <code>ConnectionSupplier</code> is responsible for providing connections to your database, as well as some metadata.</p> <p>Requesting the connection supplier service is not recommended, you should instead use <code>Database</code> (Kotlin) and <code>BlockingDatabase</code> (Java).</p> <p>If you wish not to use these abstractions, you can use their <code>fetchConnection</code> methods, to at least take advantage of statement logging and long transaction reports.</p> <p>We'll also use HikariCP, a connection pool that will reduce latency a lot when often reacquiring connections.</p> <p>Creating a datasource requires implementing <code>HikariSourceSupplier</code>, where you can directly give the connection details, that's it.</p> Example PostgreSQLH2  Kotlin Java <pre><code>@BService\nclass DatabaseSource(config: Config) : HikariSourceSupplier {\n    override val source = HikariDataSource(HikariConfig().apply {\n        // Suppose those are your config values\n        jdbcUrl = config.databaseConfig.url\n        username = config.databaseConfig.user\n        password = config.databaseConfig.password\n\n        // At most 2 JDBC connections, suspends the coroutine if all connections are used\n        maximumPoolSize = 2\n        // Emits a warning and does a thread/coroutine dump after the duration\n        leakDetectionThreshold = 10.seconds.inWholeMilliseconds\n    })\n}\n</code></pre> <pre><code>@BService\npublic class DatabaseSource implements HikariSourceSupplier {\n    private final HikariDataSource source;\n\n    public DatabaseSource(Config config) {\n        final var hikariConfig = new HikariConfig();\n        // Suppose those are your config values\n        hikariConfig.setJdbcUrl(config.getDatabaseConfig().getUrl());\n        hikariConfig.setUsername(config.getDatabaseConfig().getUser());\n        hikariConfig.setPassword(config.getDatabaseConfig().getPassword());\n\n        // At most 2 JDBC connections, the database will block if all connections are used\n        hikariConfig.setMaximumPoolSize(2);\n\n        // Emits a warning and does a thread/coroutine dump after the duration (in milliseconds)\n        hikariConfig.setLeakDetectionThreshold(10000);\n\n        source = new HikariDataSource(hikariConfig);\n    }\n\n    @NotNull\n    @Override\n    public HikariDataSource getSource() {\n        return source;\n    }\n}\n</code></pre> <p>PostgreSQL connection URL</p> <p>The URL should be similar to <code>jdbc:postgresql://[HOST]:[PORT]/[DB_NAME]</code>, by default, the port is 5432.</p>  Kotlin Java <pre><code>@BService\nclass DatabaseSource : HikariSourceSupplier {\n    override val source = HikariDataSource(HikariConfig().apply {\n        // Create an in-file database with the PostgreSQL compatibility mode\n        jdbcUrl = \"jdbc:h2:./MyBotDatabase;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH\"\n\n        // At most 2 JDBC connections, suspends the coroutine if all connections are used\n        maximumPoolSize = 2\n        // Emits a warning and does a thread/coroutine dump after the duration\n        leakDetectionThreshold = 10.seconds.inWholeMilliseconds\n    })\n}\n</code></pre> <pre><code>@BService\npublic class DatabaseSource implements HikariSourceSupplier {\n    private final HikariDataSource source;\n\n    public DatabaseSource() {\n        final var hikariConfig = new HikariConfig();\n        // Create an in-file database with the PostgreSQL compatibility mode\n        hikariConfig.setJdbcUrl(\"jdbc:h2:./MyBotDatabase;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH\");\n\n        // At most 2 JDBC connections, the database will block if all connections are used\n        hikariConfig.setMaximumPoolSize(2);\n\n        // Emits a warning and does a thread/coroutine dump after the duration (in milliseconds)\n        hikariConfig.setLeakDetectionThreshold(10000);\n\n        source = new HikariDataSource(hikariConfig);\n    }\n\n    @NotNull\n    @Override\n    public HikariDataSource getSource() {\n        return source;\n    }\n}\n</code></pre> <p>This will create a database stored in a file called <code>MyBotDatabase</code>, in the current working directory, see more details on the H2 website.</p>"},{"location":"using-botcommands/database/#using-migration","title":"Using migration","text":"<p>The framework's tables may be automatically created and migrated on updates, while the migration scripts uses a naming scheme compatible with Flyway, it may work with other migration libraries.</p> How Flyway works, simplified <p>The library maintains it's own table, which contains the migration scripts it has executed, including some data about them, like their hash.</p> <p>When you run it, Flyway will check the migrations it found, in the location you told it to look into, and then checks which one already ran, in the chronological order (that's why you name them following a pattern).</p> <p>Migrations that were not applied will run, after which they can't be modified anymore.</p> <p>Using <code>ServiceLoader</code>-based libraries</p> <p>Libraries like Flyway, PostgreSQL and SLF4J, uses a <code>ServiceLoader</code> which requires having files in your JAR to load these services.</p> <p>While creating your JAR, your build tools needs to be configured to merge those files properly, as it would overwrite those files when multiple libraries target a common interface, causing missing services.</p> <p>You can see how it's done in this Setup section.</p>"},{"location":"using-botcommands/database/#migrating-the-framework-schema","title":"Migrating the framework schema","text":"<p>After creating your <code>ConnectionSupplier</code>, you can run:</p> <pre><code>Flyway.configure()\n    .dataSource(source) // Your already existing data source\n    .schemas(\"bc\") // The name of the internal schema\n    .locations(\"bc_database_scripts\") // Where the migration scripts are located\n    .validateMigrationNaming(true)\n    .loggers(\"slf4j\") // Both JDA and BC logs using SLF4J\n    .load()\n    .migrate() // Create or update existing schema\n</code></pre>"},{"location":"using-botcommands/database/#migrating-your-own-schema","title":"Migrating your own schema","text":"<p>Migrating your own schema is very similar to the code above, here are a few guidelines:</p> <ol> <li>Replace the schema (<code>bc</code>) with your own</li> <li>Replace the location of your migration scripts (<code>bc_database_scripts</code>) to your own (like <code>[bot name]_database_scripts)</code></li> <li>Each migration script must be named similar to <code>V[version].[date]__[Description_text].sql</code>, for example:    <code>V1.2.3.2024.11.23__Add_tags.sql</code></li> <li>After running a migration script, it cannot be modified. You can always delete your schema to start over.</li> <li>Do not use <code>IF NOT EXISTS</code> in your SQL,    it is not necessary since your schema should be empty (or even non-existant) when the migrations run,    and will cause unexpected issues if data definitions already exist.</li> </ol>"},{"location":"using-botcommands/database/#configuration","title":"Configuration","text":""},{"location":"using-botcommands/database/#logging-statements","title":"Logging statements","text":"<p>SQL Statements can be logged if:</p> <ul> <li><code>BDatabaseConfig#logQueries</code> is enabled,   and the logger of the class that created the prepared statement has its <code>TRACE</code> logs enabled</li> <li>Or, <code>BDatabaseConfig#queryLogThreshold</code> is configured,   and the logger of the class that created the prepared statement has its <code>WARN</code> logs enabled</li> </ul> <p>Ignoring utility classes creating prepared statements</p> <p>If you are creating a prepared statement in a class unrelated to what actually uses the statement, the queries will be logged using the unrelated class.</p> <p>The logger used is the first class in the call stack that's not annotated with <code>@IgnoreStackFrame</code>, you may use this annotation on your class, making the logger use the caller class.</p> <p>You can alternatively use <code>withLogger</code> to manually set the logger of a prepared statement.</p>"},{"location":"using-botcommands/database/#report-long-transactions","title":"Report long transactions","text":"<p>A thread/coroutine dump can be created when the connection has a longer lifetime than expected, refer to <code>BDatabaseConfig#dumpLongTransactions</code> for more details.</p>"},{"location":"using-botcommands/database/#sample-usages","title":"Sample usages","text":""},{"location":"using-botcommands/database/#running-a-statement-returning-a-value","title":"Running a statement, returning a value","text":"Kotlin Java <pre><code>        val tagCount: Long = database.preparedStatement(\"SELECT count(*) FROM tag\") {\n            val dbResult = executeQuery().read() //Read a single row\n            dbResult[1] // Indexes start at 1\n        }\n</code></pre> <pre><code>        final long tagCount = database.withStatement(\"SELECT count(*) FROM tag\", statement -&gt; {\n            return statement.executeQuery().read() //Read a single row\n                    .getLong(1); // Indexes start at 1\n        });\n</code></pre>"},{"location":"using-botcommands/database/#running-a-statement-returning-rows","title":"Running a statement, returning rows","text":"Kotlin Java <pre><code>        val tagNames: List&lt;String&gt; = database.preparedStatement(\"SELECT name FROM tag\") {\n            // Reads all rows and convert them to strings (type inference with List&lt;String&gt;)\n            executeQuery().map { it[\"name\"] }\n        }\n</code></pre> <pre><code>        final List&lt;String&gt; tagNames = database.withStatement(\"SELECT name FROM tag\", statement -&gt; {\n            // Reads all rows and convert them to strings\n            return statement.executeQuery()\n                    .stream()\n                    .map(result -&gt; result.getString(\"name\"))\n                    .toList();\n        });\n</code></pre>"},{"location":"using-botcommands/database/#running-multiple-statements-in-a-transaction-statement","title":"Running multiple statements in a transaction statement","text":"Kotlin Java <pre><code>            database.transactional {\n                // This should not be in the database since the next query will fail, thus reverting the transaction\n                preparedStatement(\"INSERT INTO tag (name, content) VALUES ('should_not_be_here', 'should not be here')\") {\n                    executeUpdate()\n                }\n                // This will raise an exception as the name has a constraint matching ^[\\w-]+$ (spaces aren't allowed, for example)\n                preparedStatement(\"INSERT INTO tag (name, content) VALUES ('invalid name', 'foo')\") {\n                    executeUpdate()\n                }\n            }\n</code></pre> <pre><code>            database.withTransaction(transaction -&gt; {\n                // This should not be in the database since the next query will fail, thus reverting the transaction\n                transaction.withStatement(\"INSERT INTO tag (name, content) VALUES ('should_not_be_here', 'should not be here')\", statement -&gt; {\n                    statement.executeUpdate();\n                    return null;\n                });\n                // This will raise an exception as the name has a constraint matching ^[\\w-]+$ (spaces aren't allowed, for example)\n                transaction.withStatement(\"INSERT INTO tag (name, content) VALUES ('invalid name', 'foo')\", statement -&gt; {\n                    statement.executeUpdate();\n                    return null;\n                });\n                return null;\n            });\n</code></pre>"},{"location":"using-botcommands/database/#running-a-single-statement-returning-generated-keys","title":"Running a single statement, returning generated keys","text":"Kotlin Java <pre><code>        val createdAt: Instant = database.preparedStatement(\n            \"INSERT INTO tag (name, content) VALUES ('new_tag', 'new content')\",\n            columnNames = arrayOf(\"created_at\") // This is required as this is a generated column\n        ) {\n            executeReturningUpdate() // executeUpdate() + getGeneratedKeys()\n                .read() //Read a single row\n                .getTimestamp(\"created_at\").toInstant()\n        }\n</code></pre> <pre><code>        final Instant createdAt = database.withStatement(\n                \"INSERT INTO tag (name, content) VALUES ('new_tag', 'new content')\",\n                new String[]{\"created_at\"}, // This is required as this is a generated column\n                statement -&gt; {\n                    return statement.executeReturningUpdate() // executeUpdate() + getGeneratedKeys()\n                            .read() //Read a single row\n                            .getTimestamp(\"created_at\").toInstant();\n                });\n</code></pre>"},{"location":"using-botcommands/events/","title":"Using events","text":"<p>Note</p> <p>This is a wiki stub, while this allows you to know such features exist, there is little to no content about it, however, you can:</p> <ul> <li>Ask questions about it in the support server</li> <li>Help create this wiki by contributing directly, or by suggesting what topics should be explained,   how they should be structured, give relevant use cases/examples...</li> </ul>"},{"location":"using-botcommands/events/#conditional-event-listeners-based-on-available-intents","title":"Conditional event listeners based on available intents","text":"<p>Use <code>@RequiredIntents</code>.</p> <p>Tip</p> <p>You can also use <code>@RequiredIntents</code> for classes other than events listeners, for example, you might toggle an entire feature off if the required intents are not enabled.</p>"},{"location":"using-botcommands/events/#listening-to-events","title":"Listening to events","text":"<p>Use <code>@BEventListener</code>.</p>"},{"location":"using-botcommands/events/#listener-modes","title":"Listener modes","text":"<p>See <code>BEventListener.mode</code></p>"},{"location":"using-botcommands/events/#lifecycle-events","title":"Lifecycle events","text":"<p>Here is a list of events in the order they fire:</p>"},{"location":"using-botcommands/events/#initialization-events","title":"Initialization events","text":"<ul> <li><code>BStatusChangeEvent</code></li> <li><code>PreLoadEvent</code></li> <li><code>LoadEvent</code></li> <li><code>PostLoadEvent</code></li> <li><code>BReadyEvent</code></li> </ul>"},{"location":"using-botcommands/events/#jda-events","title":"JDA events","text":"<ul> <li><code>InjectedJDAEvent</code></li> <li><code>PreFirstGatewayConnectEvent</code></li> <li><code>FirstGuildReadyEvent</code></li> </ul>"},{"location":"using-botcommands/extensions/","title":"Kotlin extensions","text":"<p>In addition to what JDA-KTX offers, Kotlin users have access to top-level functions and extensions in various categories:</p>"},{"location":"using-botcommands/extensions/#jda","title":"JDA","text":""},{"location":"using-botcommands/extensions/#rest-actions","title":"REST actions","text":"<code>RestAction&lt;*&gt;.awaitUnit</code> \u2014 Awaits completion and returns <code>Unit</code>, particularly useful to reply + return <pre><code>fun onSlashCommand(event: GuildSlashEvent, inputUser: InputUser)\n    val member = inputUser.member\n        ?: return event.reply_(\"The user needs to be a member of this server!\", ephemeral = true).awaitUnit()\n}\n</code></pre> <code>RestAction&lt;R&gt;.awaitOrNullOn</code> \u2014 Awaits completion, returns <code>null</code> if the action failed with the expected error response <pre><code>fun onSlashBanInfo(event: GuildSlashEvent, user: User)\n    val ban = event.guild.retrieveBan(user).awaitOrNullOn(ErrorResponse.UNKNOWN_BAN)\n        ?: return event.reply_(\"This user is not banned\", ephemeral = true).awaitUnit()\n}\n</code></pre> <code>RestAction&lt;R&gt;.awaitCatching</code> \u2014 Awaits completion and returns a <code>Result</code> with the wrapped value/failure <pre><code>fun onSlashBanInfo(event: GuildSlashEvent, user: User)\n    val ban = event.guild.retrieveBan(user).awaitCatching()\n        .onErrorResponse(ErrorResponse.UNKNOWN_BAN) {\n            return event.reply_(\"This user is not banned\", ephemeral = true).awaitUnit()\n        }\n        .getOrThrow()\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#error-response-handling","title":"Error response handling","text":"<ul> <li><code>RestResult&lt;T&gt;.onErrorResponse</code> \u2014 Runs code if the specified error response was returned, see <code>awaitCatching</code> above</li> <li><code>RestResult&lt;T&gt;.ignore</code> \u2014 Ignores and clears the specified error responses</li> <li><code>RestResult&lt;T&gt;.handle</code> \u2014 Replaced the specified error response with the calculated value</li> </ul> <code>runIgnoringResponse</code> \u2014 Runs the block and ignores the following error responses, throws other exceptions <pre><code>runIgnoringResponse(ErrorResponse.CANNOT_SEND_TO_USER) {\n    channel.sendMessage(msg).await()\n}\n</code></pre> <code>runIgnoringResponseOrNull</code> \u2014 Runs the block and returns <code>null</code> on the following error responses, throws other exceptions <pre><code>suspend fun Guild.retrieveBanOrNull(user: UserSnowflake): Ban? = runIgnoringResponseOrNull(ErrorResponse.UNKNOWN_BAN) {\n    retrieveBan(user).await() // Can also use awaitOrNullOn, removing runIgnoringResponseOrNull\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#messages","title":"Messages","text":"<ul> <li><code>MessageCreateData.toEditData</code> \u2014 Does what it says, the edit data will replace the content of the entire message</li> <li> <p><code>MessageEditData.toCreateData</code> \u2014 Do I need to say anything?</p> </li> <li> <p><code>MessageCreateData.send</code> \u2014 Sends the message, this is useful for chaining</p> </li> <li><code>MessageEditData.edit</code> \u2014 Edits with that message, this is useful for chaining</li> <li> <p><code>InteractionHook.replaceWith</code> \u2014 Replaces this interaction's message with the following content</p> </li> <li> <p><code>RestAction&lt;R&gt;.deleteDelayed</code> \u2014 Deletes the message after the delay, the rest action itself is delayed, not the code execution (unless you use <code>await</code>)</p> </li> </ul>"},{"location":"using-botcommands/extensions/#entity-retrieval","title":"Entity retrieval","text":"<p>Those check the cache before doing a request.</p>"},{"location":"using-botcommands/extensions/#members","title":"Members","text":"<ul> <li><code>Guild.retrieveMemberOrNull</code> \u2014 Returns null if the member does not exist</li> <li><code>Guild.retrieveMemberByIdOrNull</code> \u2014 Returns null if the member does not exist</li> </ul>"},{"location":"using-botcommands/extensions/#users","title":"Users","text":"<ul> <li><code>JDA.retrieveUserOrNull</code> \u2014 Returns null if the user does not exist</li> <li><code>JDA.retrieveUserByIdOrNull</code> \u2014 Returns null if the user does not exist</li> </ul>"},{"location":"using-botcommands/extensions/#stickers","title":"Stickers","text":"<ul> <li><code>JDA.retrieveStickerOrNull</code> \u2014 Returns null if the sticker does not exist</li> </ul>"},{"location":"using-botcommands/extensions/#entitlements","title":"Entitlements","text":"<ul> <li><code>JDA.retrieveEntitlementByIdOrNull</code> \u2014 Returns null if the entitlement does not exist</li> </ul>"},{"location":"using-botcommands/extensions/#webhooks","title":"Webhooks","text":"<ul> <li><code>JDA.retrieveWebhookByIdOrNull</code> \u2014 Returns null if the webhook does not exist</li> </ul>"},{"location":"using-botcommands/extensions/#threads-unofficial-support","title":"Threads (unofficial support)","text":"<ul> <li><code>Guild.retrieveThreadChannelById</code> \u2014 Retrieves a thread by ID, from any thread container, archived or not.</li> <li><code>Guild.retrieveThreadChannelOrNull</code> \u2014 Same but returns null if it does not exist, if the bot doesn't have access to it, or if the channel isn't a thread.</li> </ul>"},{"location":"using-botcommands/extensions/#misc","title":"Misc","text":"<code>suppressContentWarning</code> \u2014 Runs the block and suppresses warnings emitted by JDA when reading message content, this is mostly useful in message context commands <pre><code>val contentRaw = suppressContentWarning { message.contentRaw }\n</code></pre> <ul> <li><code>getMissingPermissions</code> \u2014 Gets the missing permissions from the required permissions, for the given entity, in the specified channel</li> </ul> <p>Any method accepting a Java <code>Duration</code> should also have an extension using Kotlin's <code>Duration</code></p>"},{"location":"using-botcommands/extensions/#resolvers","title":"Resolvers","text":"<code>enumResolver</code> \u2014 Creates a parameter resolver which transforms arguments into an enum entry, compatible with most handlers <pre><code>enum class MyEnum {\n    FIRST,\n    SECOND,\n    THIRD\n}\n\n@BConfiguration\nclass MyEnumResolverProvider {\n    // Creates an enum resolver for all values\n    // you can also customize what values can be used, per-guild,\n    // and also change how they are displayed\n    @Resolver\n    fun myEnumResolver() = enumResolver&lt;MyEnum&gt;()\n}\n</code></pre> <code>resolverFactory</code> \u2014 Creates a factory for parameter resolvers, useful to avoid the boilerplate of using <code>TypedParameterResolverFactory</code> <p>See example on the docs</p>"},{"location":"using-botcommands/extensions/#io","title":"I/O","text":"<code>readResource</code> \u2014 Gets an <code>InputStream</code> of a resource from the classpath <pre><code>readResource(\"/file.txt\").use { contentStream -&gt;\n    // ...\n}\n</code></pre> <code>readResourceAsString</code> \u2014 Gets a resource from the classpath as a <code>String</code> <pre><code>val content = readResourceAsString(\"/file.txt\")\n</code></pre> <code>withResource</code> \u2014 Uses an <code>InputStream</code> of a resource from the classpath <pre><code>withResource(\"/file.txt\") { contentStream -&gt;\n    // ...\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#coroutines","title":"Coroutines","text":"<code>namedDefaultScope</code> \u2014 Creates a <code>CoroutineScope</code> with a thread name and a fixed thread pool <pre><code>// 1 thread named \"[feature] timeout\"\n// You can also configure other CoroutineScope characteristics\nprivate val timeoutScope = namedDefaultScope(\"[feature] timeout\", corePoolSize = 1)\n\n// ...\n\ntimeoutScope.launch {\n    // Async task\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#logging","title":"Logging","text":"<code>KotlinLogging.loggerOf</code> \u2014 Creates a logger targeting the specified class <pre><code>private val logger = KotlinLogging.loggerOf&lt;MyService&gt;()\n\n@BService\nclass MyServiceImpl : MyService {\n    // ...\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#collections","title":"Collections","text":"<ul> <li><code>enumSetOf</code> \u2014 Creates an enum set of the provided type</li> <li><code>enumSetOfAll</code> \u2014 Creates an enum set of the provided type, with all the entries in it</li> <li><code>enumMapOf</code> \u2014 Creates a map with an enum key</li> <li><code>List&lt;T&gt;.toImmutableList</code> \u2014 Creates an immutable copy of the list</li> <li><code>Set&lt;T&gt;.toImmutableSet</code> \u2014 Creates an immutable copy of the set</li> <li><code>Map&lt;K, V&gt;.toImmutableMap</code> \u2014 Creates an immutable copy of the map</li> <li><code>Iterable&lt;T&gt;.containsAny</code> \u2014 Checks if the collection contains any of the provided elements</li> </ul>"},{"location":"using-botcommands/extensions/#emojis","title":"Emojis","text":"<ul> <li><code>Emoji.asUnicodeEmoji</code> \u2014 Converts a JEmoji's <code>Emoji</code> into a JDA <code>UnicodeEmoji</code></li> <li><code>lazyUnicodeEmoji</code> \u2014 Lazily fetches the Unicode from the given shortcode</li> </ul>"},{"location":"using-botcommands/localization/","title":"Using localization","text":"<p>Note</p> <p>This is a wiki stub, while this allows you to know such features exist, there is little to no content about it, however, you can:</p> <ul> <li>Ask questions about it in the support server</li> <li>Help create this wiki by contributing directly, or by suggesting what topics should be explained,   how they should be structured, give relevant use cases/examples...</li> </ul>"},{"location":"using-botcommands/localization/#in-application-commands","title":"In application commands","text":"<p>See <code>AppLocalizationContext</code>, or the localized replies methods on your interaction event, usually inherited from <code>LocalizableInteraction</code>, <code>LocalizableReplyCallback</code> and <code>LocalizableEditCallback</code>.</p> <p>In a nutshell, events have a few methods which let you reply directly with a localized string and a configurable (and overridable) locale, with the translated strings coming from <code>BLocalizationConfigBuilder.responseBundles</code>.</p> <p>Messages sent using <code>InteractionHook</code> can also be localized, as the <code>getHook</code> method will now return a <code>LocalizableInteractionHook</code>.</p> <p>You can also change a few things such as the locale used by the interaction, its localization bundle, or its prefix, see the <code>LocalizableInteraction</code> docs.</p> <p>You will typically use the <code>replyUser</code> and <code>replyGuild</code> functions, letting you reply using the user/guild locale in a simple and elegant way, while allowing customization using <code>UserLocaleProvider</code> and <code>GuildLocaleProvider</code> respectively.</p>"},{"location":"using-botcommands/localization/#extending-support","title":"Extending support","text":""},{"location":"using-botcommands/localization/#how-localization-bundles-are-loaded","title":"How localization bundles are loaded","text":""},{"location":"using-botcommands/localization/#localization-map-providers","title":"Localization map providers","text":"<p>See <code>LocalizationMapProvider</code>.</p>"},{"location":"using-botcommands/localization/#localization-map-readers","title":"Localization map readers","text":"<p>See <code>LocalizationMapReader</code>.</p> <p>You can create one of your own with <code>JacksonLocalizationMapReader</code>.</p>"},{"location":"using-botcommands/localization/#localization-templates","title":"Localization templates","text":"<p>See <code>LocalizationTemplate</code>.</p>"},{"location":"using-botcommands/parameter-names/","title":"Enabling Java parameter names","text":"<p>Tip</p> <p>This is NOT required if you are using Kotlin.</p> <p>A significant part of the framework benefits from having accessible method parameter names,  such as <code>@TextOption</code> or <code>@SlashOption</code>, injecting a service by its name,  including better debugging / error messages.</p> MavenGradle <p>You can add the necessary compiler argument in the configuration for the Maven compiler plugin: pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${compiler.plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;!-- ... --&gt;\n        &lt;compilerArgs&gt;\n            &lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n        &lt;/compilerArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre></p> <p>You can add the necessary compiler argument to the Java compile options: build.gradle.kts<pre><code>tasks.withType&lt;JavaCompile&gt; {\n    options.compilerArgs += \"-parameters\"\n}\n</code></pre></p>"},{"location":"using-botcommands/ratelimit/","title":"Using rate limits","text":"<p>Rate limits lets you reject interactions when they are used too much in a time span.</p> <p>For more details, check out the docs of Bucket4J</p>"},{"location":"using-botcommands/ratelimit/#defining-a-rate-limit","title":"Defining a rate limit","text":"<p>Rate limits can be defined by implementing <code>RateLimitProvider</code>, the overridden function will run before registering commands, so you can use them anywhere.</p>"},{"location":"using-botcommands/ratelimit/#defining-bucket-configurations","title":"Defining bucket configurations","text":"<p>A <code>BucketConfiguration</code> defines what the limits are, you can supply different configurations based on the context, by implementing a <code>BucketConfigurationSupplier</code>, or you can create a configuration with the factories in <code>Buckets</code>, or with the <code>BucketConfiguration</code> builder.</p> <p>Tip</p> <p>If you want to give the same configuration regardless of context, you can use <code>BucketConfigurationSupplier.constant(BucketConfiguration)</code> (or <code>BucketConfiguration#toSupplier()</code> for Kotlin users)</p> <p>Example</p>  Kotlin Java <pre><code>// Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\nval bucketConfiguration = Buckets.spikeProtected(\n    capacity = 5,               // 5 uses\n    duration = 1.hours,         // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n    spikeCapacity = 2,          // 2 uses\n    spikeDuration = 2.minutes   // Give 2 tokens every 2 minutes\n)\n</code></pre> <pre><code>// Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\nfinal var bucketConfiguration = Buckets.createSpikeProtected(\n        5,                      // 5 uses\n        Duration.ofHours(1),    // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n        2,                      // 2 uses\n        Duration.ofMinutes(2)   // Give 2 tokens every 2 minutes\n);\n</code></pre>"},{"location":"using-botcommands/ratelimit/#creating-a-rate-limiter","title":"Creating a rate limiter","text":"<p>The default rate limiters should provide you ready-made implementations for both in-memory and proxied buckets, refer to the example attached to them.</p> <p>Example</p>  Kotlin Java <pre><code>val rateLimiter = RateLimiter.createDefault(\n    // Apply to each user, regardless of channel/guild\n    RateLimitScope.USER,\n    // Delete the message telling the user about the remaining rate limit after it expires\n    deleteOnRefill = true,\n    // Give our constant bucket configuration\n    configurationSupplier = bucketConfiguration.toSupplier()\n)\n</code></pre> <pre><code>final var rateLimiter = RateLimiter.createDefault(\n        // Apply to each user, regardless of channel/guild\n        RateLimitScope.USER,\n        // Give our constant bucket configuration\n        BucketConfigurationSupplier.constant(bucketConfiguration),\n        // Delete the message telling the user about the remaining rate limit after it expires\n        true\n);\n</code></pre> <p>However, you can also create a custom one by implementing <code>RateLimiter</code>, which is the combination of:</p> <ul> <li><code>BucketAccessor</code>: Retrieves a <code>Bucket</code> based on the context</li> <li><code>RateLimitHandler</code>: Handles when an interaction has been rate limited (often to tell the user about it)</li> </ul> <p>Tip</p> <p>When making a custom rate limiter, you can delegate one of the default implementations to avoid reimplementing existing behavior.</p> <p>You can also use <code>BucketKeySupplier</code> to help you define functions returning a bucket key (an identifier basically), based on the execution context.</p>"},{"location":"using-botcommands/ratelimit/#registering-the-rate-limiter","title":"Registering the rate limiter","text":"<p>You can now register using <code>RateLimitManager#rateLimit(String, RateLimiter)</code>, the <code>group</code> (name of the rate limiter) must be unique.</p> <p>Full example</p>  Kotlin Java <pre><code>@BService\nclass WikiRateLimitProvider : RateLimitProvider {\n\n    override fun declareRateLimit(manager: RateLimitManager) {\n        // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n        val bucketConfiguration = Buckets.spikeProtected(\n            capacity = 5,               // 5 uses\n            duration = 1.hours,         // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n            spikeCapacity = 2,          // 2 uses\n            spikeDuration = 2.minutes   // Give 2 tokens every 2 minutes\n        )\n\n        val rateLimiter = RateLimiter.createDefault(\n            // Apply to each user, regardless of channel/guild\n            RateLimitScope.USER,\n            // Delete the message telling the user about the remaining rate limit after it expires\n            deleteOnRefill = true,\n            // Give our constant bucket configuration\n            configurationSupplier = bucketConfiguration.toSupplier()\n        )\n\n        // Register, any command can use it\n        manager.rateLimit(RATE_LIMIT_GROUP, rateLimiter)\n    }\n\n    companion object {\n        // The name of the rate limit, so you can reference it in your commands/components\n        const val RATE_LIMIT_GROUP = \"Wiki\"\n    }\n}\n</code></pre> <pre><code>@BService\npublic class WikiRateLimitProvider implements RateLimitProvider {\n    // The name of the rate limit, so you can reference it in your commands/components\n    public static final String RATE_LIMIT_GROUP = \"Wiki\";\n\n    @Override\n    public void declareRateLimit(@NotNull RateLimitManager rateLimitManager) {\n        // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n        final var bucketConfiguration = Buckets.createSpikeProtected(\n                5,                      // 5 uses\n                Duration.ofHours(1),    // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n                2,                      // 2 uses\n                Duration.ofMinutes(2)   // Give 2 tokens every 2 minutes\n        );\n\n        final var rateLimiter = RateLimiter.createDefault(\n                // Apply to each user, regardless of channel/guild\n                RateLimitScope.USER,\n                // Give our constant bucket configuration\n                BucketConfigurationSupplier.constant(bucketConfiguration),\n                // Delete the message telling the user about the remaining rate limit after it expires\n                true\n        );\n\n        // Register\n        rateLimitManager.rateLimit(RATE_LIMIT_GROUP, rateLimiter);\n    }\n}\n</code></pre>"},{"location":"using-botcommands/ratelimit/#cancelling-rate-limits","title":"Cancelling rate limits","text":"<p>If your interaction does an early return, you can also return the token with <code>cancelRateLimit()</code>,  so the user won't get penalized for this interaction.</p> <p>Example</p>  Kotlin Java <pre><code>suspend fun onSlashRateLimit(event: GuildSlashEvent) {\n    // Assuming we have voice states cached\n    if (!event.member.voiceState!!.inAudioChannel()) {\n        // Note that this would be easier done using a filter,\n        // as no token would be used, and would also be cleaner.\n        event.cancelRateLimit()\n        return event.reply_(\"You must be in a voice channel\").awaitUnit()\n    }\n\n    event.reply(\"Hello world!\").await()\n}\n</code></pre> <pre><code>public void onSlashRateLimit(GuildSlashEvent event) {\n    // Assuming we have voice states cached\n    if (!event.getMember().getVoiceState().inAudioChannel()) {\n        // Note that this would be easier done using a filter,\n        // as no token would be used, and would also be cleaner.\n        event.cancelRateLimit();\n        event.reply(\"You must be in a voice channel\").queue();\n        return;\n    }\n\n    event.reply(\"Hello world!\").queue();\n}\n</code></pre>"},{"location":"using-botcommands/dependency-injection/","title":"Dependency injection","text":"<p>Dependency injection provided by this framework is a more lightweight alternative to dedicated frameworks, quite similarly to Spring (which is supported)  or CDI using Weld.</p> <p>Rather than you having to construct objects, you may only request them, the framework will then construct it by providing the dependencies required for your service, wherever they may come from.</p> <p>This avoids having to pass objects everywhere, allowing a more effective decoupling, and allows switching implementations in a completely transparent manner.</p> <p>Example</p> <p><code>ConnectionSupplier</code> is an interfaced service (an interface that, when implemented, enables the service to be retrieved as such interface).</p> <p>You can create an implementation of this interface, per database, enabling you to switch your database,  for example, using a configuration file, without changing anything else in your code.</p> 2.X Migration <p>All singletons / classes with static methods were moved as services, including:</p> <ul> <li><code>Components</code></li> <li><code>EventWaiter</code></li> <li><code>Localization</code></li> </ul> <p>If you were using <code>ExtensionsBuilder#registerConstructorParameter(Class&lt;T&gt;, ConstructorParameterSupplier&lt;T&gt;)</code> to get objects in commands,  it is basically the same, except in a much more complete framework, and without having to declare everything with this method.</p> 2.X3.X  Kotlin Java TagDatabase.kt<pre><code>class TagDatabase { /* */ }\n</code></pre> TagCommand.kt<pre><code>class TagCommand(private val tagDatabase: TagDatabase) {\n    /* */\n}\n</code></pre> Builder<pre><code>val tagDatabase = TagDatabase(/* */);\n\nCommandsBuilder.newBuilder()\n    .registerConstructorParameter(TagDatabase::class.java) { tagDatabase }\n    // Further configuration\n    .build();\n</code></pre> TagDatabase.java<pre><code>public class TagDatabase { /* */ }\n</code></pre> TagCommand.java<pre><code>public class TagCommand {\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(TagDatabase tagDatabase) {\n        this.tagDatabase = tagDatabase;\n    }\n}\n</code></pre> Builder<pre><code>final var tagDatabase = new TagDatabase(/* */);\n\nCommandsBuilder.newBuilder()\n    .registerConstructorParameter(TagDatabase.class, clazz -&gt; tagDatabase)\n    // Further configuration\n    .build();\n</code></pre>  Kotlin Java TagDatabase.kt<pre><code>@BService //Makes this class injectable, can also pull other services in its constructor\nclass TagDatabase { /* */ }\n</code></pre> TagCommand.kt<pre><code>@Command\nclass TagCommand(private val tagDatabase: TagDatabase) {\n    /* */\n}\n</code></pre> <p>No specific builder code required!</p> TagDatabase.java<pre><code>@BService //Makes this class injectable, can also pull other services in its constructor\npublic class TagDatabase { /* */ }\n</code></pre> TagCommand.java<pre><code>@Command\npublic class TagCommand {\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(TagDatabase tagDatabase) {\n        this.tagDatabase = tagDatabase;\n    }\n\n    /* */\n}\n</code></pre> <p>No specific builder code required!</p>"},{"location":"using-botcommands/dependency-injection/creating-services/","title":"Creating services","text":"<p>To register a class as a service, add <code>@BService</code> to your class declaration.</p> <p><code>@BService</code> is the base annotation to register a service,  other annotations exist such as <code>@Command</code> and <code>@Resolver</code>,  but the appropriate documentation will specify if such alternatives are required.</p> <p>Info</p> <p>All classes available for dependency injection must be in the framework's classpath, by adding packages to <code>BConfigBuilder#packages</code>, or by using <code>BConfigBuilder#addSearchPath</code>,  all classes are searched recursively.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-factories","title":"Service factories","text":"<p>Service factories are methods that create initialized services themselves, they accept other services as parameters and define a service with the method's return type.</p> <p>In addition to the package requirement, they must be annotated with <code>@BService</code>, be in a service, or in an <code>object</code>, or be a static method.</p> <p>Terminology</p> <p>Classes registered as services, and service factories, are service providers.</p> Example  KotlinKotlin property Java <pre><code>class Config {\n    /* */\n\n    companion object {\n        // Service factory, registers as Config (as it is the return type), with the name \"config\"\n        // You can use any method name, but the method name is what the service is registered as\n        @BService\n        fun config(): Config {\n            // Of course here you would load the config from a file\n            Config()\n        }\n    }\n}\n</code></pre> <pre><code>class Config {\n    /* */\n\n    companion object {\n        // Service factory, registers as Config (as it is the return type), with the name \"config\"\n        @get:BService\n        val config: Config by lazy {\n            // Of course here you would load the config from a file\n            Config()\n        }\n    }\n}\n</code></pre> <pre><code>public class Config {\n    private static Config INSTANCE = null;\n\n    /* */\n\n    // Service factory, registers as \"Config\" (as it is the return type), with the name \"config\"\n    // You can use any method name, but the method name is what the service is registered as\n    @BService\n    public static Config config() {\n        if (INSTANCE == null) {\n            // Of course here you would load the config from a file\n            INSTANCE = new Config();\n        }\n\n        return INSTANCE;\n    }\n}\n</code></pre> <p>Tip</p> <p>To suppress unused warnings on the declaring class, you can use <code>@BConfiguration</code>, unless the declaring class itself must be a service.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#conditional-services","title":"Conditional services","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Some services may not always be instantiable,  some may require soft dependencies (prevents instantiation if a service is unavailable, without failing), while some run a set of conditions to determine if a service can be instantiated.</p> <p>Services that are not instantiable will not be created at startup,  will be unavailable for injection and do not figure in the list of interfaced services.</p> <p>Info</p> <p>All the following annotations must be used alongside a service-declaring annotation,  such as <code>@BService</code> or <code>@Command</code>.</p> <p>Tip</p> <p>There is a few built-in conditional annotations, such as:</p> <ul> <li><code>@RequiredIntents</code>: Enables a service if the <code>JDAService</code> has the specified intents enabled.</li> <li><code>@RequiresDatabase</code>: Enables a service if a <code>(Blocking)Database</code> instance is available.</li> <li><code>@RequiresComponents</code>: Enables a service if components are enabled.</li> </ul>"},{"location":"using-botcommands/dependency-injection/creating-services/#dependencies","title":"Dependencies","text":"<p>The <code>@Dependencies</code> annotation lets you define soft dependencies, that is, if any of these classes in the annotation are unavailable, your service will not be instantiated.</p> <p>Without the annotation, any unavailable dependency would throw an exception.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#interfaced-conditions","title":"Interfaced conditions","text":"<p><code>@ConditionalService</code> defines a list of classes implementing <code>ConditionalServiceChecker</code>, the service is only created if none of these classes return an error message.</p> <p><code>ConditionalServiceChecker</code> can be implemented on any class that has a no-arg constructor, or is an <code>object</code>.</p> Example  Kotlin Java <pre><code>@Command\n@ConditionalService(TagCommand.FeatureCheck::class) // Only create the command if this passes\nclass TagCommand {\n    /* */\n\n    object FeatureCheck : ConditionalServiceChecker {\n        override fun checkServiceAvailability(serviceContainer: ServiceContainer, checkedClass: Class&lt;*&gt;): String? {\n            val config = serviceContainer.getService&lt;Config&gt;() // Suppose this is your configuration\n            if (!config.enableTags) {\n                return \"Tags are disabled in the configuration\" // Do not allow the tag command!\n            }\n            return null // No error message, allow the tag command!\n        }\n    }\n}\n</code></pre> <pre><code>@Command\n@ConditionalService(TagCommand.FeatureCheck.class) // Only create the command if this passes\npublic class TagCommand {\n    /* */\n\n    public static class FeatureCheck implements ConditionalServiceChecker {\n        @Nullable\n        @Override\n        public String checkServiceAvailability(@NotNull ServiceContainer serviceContainer, @NotNull Class&lt;?&gt; checkedClass) {\n            final var config = serviceContainer.getService(Config.class); // Suppose this is your configuration\n            if (!config.areTagsEnabled()) {\n                return \"Tags are disabled in the configuration\"; // Do not allow the tag command!\n            }\n            return null; // No error message, allow the tag command!\n        }\n    }\n}\n</code></pre>"},{"location":"using-botcommands/dependency-injection/creating-services/#annotation-conditions","title":"Annotation conditions","text":"<p><code>@Condition</code> is a meta-annotation (an annotation for annotations) which marks your own annotation as being a condition.</p> <p>Similar to interfaced conditions, they must refer to an implementation of <code>CustomConditionChecker</code>,  to determine if the annotated service can be created,  you can also indicate if the service creation must throw an exception in case it fails.</p> <p>The implementation must have a no-arg constructor, or be an <code>object</code></p> <p>Note</p> <p>The annotation must also be in the framework's classpath.</p> Example  Kotlin Java DevCommand.kt<pre><code>// Same targets as service annotations\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER)\n// The implementation of our CustomConditionChecker\n@Condition(type = DevCommandChecker::class)\nannotation class DevCommand\n\n// Checks services annotated with @DevCommand\nobject DevCommandChecker : CustomConditionChecker&lt;DevCommand&gt; {\n    override val annotationType: Class&lt;DevCommand&gt; = DevCommand::class.java\n\n    override fun checkServiceAvailability(serviceContainer: ServiceContainer, checkedClass: Class&lt;*&gt;, annotation: DevCommand): String? {\n        val config = serviceContainer.getService&lt;Config&gt;() // Suppose this is your configuration\n        if (!config.enableDevMode) {\n            return \"Dev mode is disable in the configuration\" // Do not allow the dev commands!\n        }\n        return null // No error message, allow the tag command!\n    }\n}\n</code></pre> SlashShutdown.kt<pre><code>@Command\n@DevCommand // Our custom condition, this command will only exist if it passes.\nclass SlashShutdown {\n    /* */\n}\n</code></pre> DevCommand.java<pre><code>// Same targets as service annotations\n@Target({ElementType.TYPE, ElementType.METHOD})\n// The implementation of our CustomConditionChecker\n@Condition(type = DevCommandChecker.class)\npublic @interface DevCommand { }\n</code></pre> DevCommandChecker.java<pre><code>// Checks services annotated with @DevCommand\npublic class DevCommandChecker implements CustomConditionChecker&lt;DevCommand&gt; {\n    @NotNull\n    @Override\n    public Class&lt;DevCommand&gt; getAnnotationType() {\n        return DevCommand.class;\n    }\n\n    @Nullable\n    @Override\n    public String checkServiceAvailability(@NotNull ServiceContainer serviceContainer, @NotNull Class&lt;?&gt; checkedClass, @NotNull DevCommand annotation) {\n        final var config = serviceContainer.getService(Config.class); // Suppose this is your configuration\n        if (!config.isDevModeEnabled()) {\n            return \"Dev mode is disable in the configuration\"; // Do not allow the dev commands!\n        }\n        return null; // No error message, allow the tag command!\n    }\n}\n</code></pre> SlashShutdown.java<pre><code>@Command\n@DevCommand // Our custom condition, this command will only exist if it passes.\npublic class SlashShutdown {\n    /* */\n}\n</code></pre>"},{"location":"using-botcommands/dependency-injection/creating-services/#interfaced-services","title":"Interfaced services","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Interfaced services are interfaces, or abstract class, marked by <code>@InterfacedService</code>, they must be implemented by a service.</p> <p>In addition to the service's type, implementations of these annotated interfaces have the interface's type automatically added.</p> <p>Some interfaced services may only be implemented once, some may allow multiple implementations, if an interfaced service only accepts one implementation, multiple implementations can exist, but only one must be instantiable.</p> <p>Creating multiple interfaced services in one</p> <p>You can implement multiple interfaced services at once,  which may be useful for text, application and component filters.</p> <p>Creating interfaced services without registering the interface type</p> <p>You can also implement an interfaced service, without it being accessible as such,  by using <code>@IgnoreServiceTypes</code>.</p> 2.X Migration <p>Most methods in <code>CommandsBuilder</code> accepting interfaces, implementations or lambdas, were moved to interfaced services:</p> <p>Global:</p> <ul> <li><code>CommandsBuilder#setComponentManager</code>: Removed, using components must be enabled in <code>BComponentsConfigBuilder#enable</code>, and a <code>ConnectionSupplier</code> service be present</li> <li><code>CommandsBuilder#setSettingsProvider</code>: Needs to implement <code>SettingsProvider</code></li> <li><code>CommandsBuilder#setUncaughtExceptionHandler</code>: Needs to implement <code>GlobalExceptionHandler</code></li> <li><code>CommandsBuilder#setDefaultEmbedFunction</code>: Needs to implement <code>DefaultEmbedSupplier</code> and <code>DefaultEmbedFooterIconSupplier</code></li> </ul> <p>Text commands:</p> <ul> <li><code>TextCommandBuilder#addTextFilter</code>: Needs to implement <code>TextCommandFilter</code>, and <code>TextCommandRejectionHandler</code></li> <li><code>TextCommandBuilder#setHelpBuilderConsumer</code>: Needs to implement <code>HelpBuilderConsumer</code></li> </ul> <p>Application commands:</p> <ul> <li><code>ApplicationCommandBuilder#addApplicationFilter</code>: Needs to implement <code>ApplicationCommandFilter</code>, and <code>ApplicationCommandRejectionHandler</code></li> <li><code>ApplicationCommandBuilder#addComponentFilter</code>: Needs to implement <code>ComponentCommandFilter</code>, and <code>ComponentCommandRejectionHandler</code></li> </ul> <p>Extensions:</p> <ul> <li><code>ExtensionsBuilder#registerAutocompletionTransformer</code>: Needs to implement <code>AutocompleteTransformer</code></li> <li><code>ExtensionsBuilder#registerCommandDependency</code>: Replaced with standard dependency injection</li> <li><code>ExtensionsBuilder#registerConstructorParameter</code>: Replaced with standard dependency injection</li> <li><code>ExtensionsBuilder#registerCustomResolver</code>: Needs to implement <code>ClassParameterResolver</code> and <code>ICustomResolver</code></li> <li><code>ExtensionsBuilder#registerDynamicInstanceSupplier</code>: Needs to implement <code>DynamicSupplier</code></li> <li><code>ExtensionsBuilder#registerInstanceSupplier</code>: Replaced by service factories</li> <li><code>ExtensionsBuilder#registerParameterResolver</code>: Needs to implement <code>ClassParameterResolver</code> and the resolver interface of your choices</li> </ul>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-properties","title":"Service properties","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Service providers can have names, additional registered types, and an instantiation priority.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-names","title":"Service names","text":"<p>Named services may be useful if you have multiple services of the same type, but need to get a specific one.</p> <p>The name is either defined by using <code>@ServiceName</code>, or with <code>BService#name</code> on the service provider.</p> <p>Example</p> <p>You can have a caching <code>HttpClient</code> named <code>cachingHttpClient</code>, while the usual client uses the default name.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-types","title":"Service types","text":"<p>In addition to the type of the service provider,  <code>@ServiceType</code> enables you to register a service as a supertype.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-priority","title":"Service priority","text":"<p>Service priorities control how service providers are sorted.</p> <p>A higher priority means that the service will be loaded first, or that an interfaced service will appear first when requesting interfaced services.</p> <p>The priority is either defined by using <code>@ServicePriority</code>, or with <code>BService#priority</code> on the service provider,  see their documentation to learn what how service providers are sorted.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/","title":"Retrieving services","text":"<p>Any class given by a service provider can be injected into other service providers,  requesting a service is as simple as declaring a parameter in the class's constructor,  or the service factory's parameters.</p> <p>Named services can be retrieved by using <code>@ServiceName</code> on the parameter, this can be omitted if the parameter name matches a service with a compatible type.</p> <p>Tip</p> <p>You can also get services manually with <code>BContext</code> or <code>ServiceContainer</code>, the latter has all methods available,  including Kotlin extensions.</p> <p>Example</p>  Kotlin Java <pre><code>@BService // Enables the service to request services and be requested\nclass TagDatabase { /* */ }\n</code></pre> <pre><code>@Command // Enables the command to request services and be requested\nclass TagCommand(\n    // You can even request framework services, as long as they are annotated with @BService or @InterfacedService\n    // Here I've named it \"componentsService\" because \"components\" might conflict with some JDA-KTX builders\n    private val componentsService: Components,\n    // and your own services\n    private val tagDatabase: TagDatabase\n) {\n    /* */\n}\n</code></pre> <pre><code>@BService // Enables the service to request services and be requested\npublic class TagDatabase { /* */ }\n</code></pre> <pre><code>@Command // Enables the command to request services and be requested\npublic class TagCommand {\n    private final Component components;\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(\n        // You can even request framework services, as long as they are annotated with @BService or @InterfacedService\n        Component components,\n        // and your own services\n        TagDatabase tagDatabase\n    ) {\n        this.components = components;\n        this.tagDatabase = tagDatabase;\n    }\n\n    /* */\n}\n</code></pre> Retrieving services by name <p>Consider the following service providers:</p>  Kotlin Java <pre><code>@BService\nclass HttpClientProvider {\n//    @Primary // This is only needed if you try to get an OkHttpClient without matching the name\n    @BService\n    fun httpClient(): OkHttpClient = OkHttpClient()\n\n    @BService\n    fun cachedHttpClient(\n        // Inject the default http client (declared above)\n        // This is not the same as calling the method! as it would create 2 different clients\n\n        // This would not work if the parameter was named differently,\n        // unless @Primary was used on the default declaration above\n        httpClient: OkHttpClient\n    ): OkHttpClient {\n        val tempDirectory = Files.createTempDirectory(null).toFile()\n        return httpClient.newBuilder()\n            .cache(Cache(tempDirectory, maxSize = 1024 * 1024))\n            .build()\n    }\n}\n</code></pre> With <code>@ServiceName</code>With parameter names <pre><code>@BService\nclass MyApi(@ServiceName(\"cachedHttpClient\") httpClient: HttpClient)\n</code></pre> <pre><code>@BService\nclass MyApi(private val cachedHttpClient: HttpClient)\n</code></pre> <pre><code>@BService\npublic class HttpClientProvider {\n//    @Primary // This is only needed if you try to get an OkHttpClient without matching the name\n    @BService\n    public OkHttpClient httpClient() {\n        return new OkHttpClient();\n    }\n\n    @BService\n    public OkHttpClient cachedHttpClient(\n            // Inject the default http client (declared above)\n            // This is not the same as calling the method! as it would create 2 different clients\n\n            // This would not work if the parameter was named differently,\n            // unless @Primary was used on the default declaration above\n            OkHttpClient httpClient\n    ) throws IOException {\n        final File tempDirectory = Files.createTempDirectory(null).toFile();\n        return httpClient.newBuilder()\n                .cache(new Cache(tempDirectory, 1024 * 1024))\n                .build();\n    }\n}\n</code></pre> With <code>@ServiceName</code>With parameter names <pre><code>@BService\npublic class MyApi {\n    public MyApi(@ServiceName(\"cachedHttpClient\") HttpClient httpClient) {\n        // ...\n    }\n}\n</code></pre> <pre><code>@BService\npublic class MyApi {\n    public MyApi(HttpClient cachedHttpClient) {\n        // ...\n    }\n}\n</code></pre> <p>Warning</p> <p>For this to work, you need to enable Java parameter names</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#primary-providers","title":"Primary providers","text":"<p>When requesting a service of a specific type/name, there must be at most one usable service provider.</p> <p>For example, if you have two service factories with the same return type:</p> <ul> <li> If both are usable</li> <li> One has a failing condition, meaning you have one usable provider</li> <li> One is annotated with <code>@Primary</code>, in which case this one is prioritized</li> </ul> <p>Note</p> <p>You can still retrieve existing services with <code>ServiceContainer#getInterfacedServices/getInterfacedServiceTypes</code></p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#interfaced-services","title":"Interfaced services","text":"<p>A list which the element type is an interfaced service can be requested, the list will then contain all instantiable instances with the specified type.</p> <p>Example</p> <p><code>List&lt;ApplicationCommandFilter&lt;?&gt;&gt;</code> will contain all instances implementing <code>ApplicationCommandFilter</code>,  which are usable.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#lazy-services","title":"Lazy services","text":"<p>Lazy service retrieval enables you to get lazily created service, delaying the initialization, or to get services that are not yet available, such as manually injected services (like <code>JDA</code>).</p> <p>Retrieving a lazy service</p>  Kotlin Java <p>Request a <code>ServiceContainer</code> and use a delegated property, such as:</p> <p><code>private val helpCommand: IHelpCommand by serviceContainer.lazy()</code></p> <p>Request a <code>LazyService</code> with the element type being the requested service,  and then get the service when needed by using <code>getValue()</code>.</p> <p>Note</p> <p>Lazy injections cannot contain a list of interfaced services,  nor can a list of lazy services be requested.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#optional-services","title":"Optional services","text":"<p>When a requested service is not available, and is not a soft-dependency,  service creation will fail.</p> <p>In case your service does not always require the service, you can prevent failure by using Kotlin's nullable / optional parameters, but Java users will need a runtime-retained <code>@Nullable</code> annotation  (such as <code>@javax.annotation.Nullable</code>, or, in checker-framework or JSpecify) or <code>@Optional</code>.</p> <p>Optional lazy services</p> <p>When you are about to request the service from <code>LazyService</code>, you can use canCreateService or getServiceError to check if it is available at this point in time.</p>"},{"location":"using-commands/advanced-options/","title":"Advanced options","text":"<p>Text and application command options can benefit from more complex option types,  by combining multiple options into one parameter,  such as varargs, mention strings and custom data structures.</p>"},{"location":"using-commands/advanced-options/#varargs","title":"Varargs","text":"<p>Varargs lets you generate options (up to 25 options per command) and put the values in a <code>List</code>, the number of required options is also configurable.</p>"},{"location":"using-commands/advanced-options/#annotation-declared-commands","title":"Annotation-declared commands","text":"<p>Use <code>@VarArgs</code> on the parameter.</p> <p>The drawback is that each option will be configured the same, name, description, etc...</p>"},{"location":"using-commands/advanced-options/#code-declared-commands","title":"Code-declared commands","text":"<p>Using <code>optionVararg</code> or <code>inlineClassOptionVararg</code> on your command builder lets you solve the above issues.</p> <p>Example</p> <pre><code>fun onSlashCommand(event: GuildSlashEvent, names: List&lt;String&gt;) {\n    // ...    \n}\n</code></pre> <pre><code>manager.slashCommand(\"command\", ::onSlashCommand) {\n    optionVararg(\n        declaredName = \"names\", // Name of the method parameter\n        amount = 5, //How many options to generate\n        requiredAmount = 1, //How many of them are required\n        optionNameSupplier = { num -&gt; \"name_$num\" } // Generate the name of each option\n    ) { num -&gt;\n        // This runs for each option\n        description = \"Name N\u00b0$num\" \n    }\n}\n</code></pre>"},{"location":"using-commands/advanced-options/#mention-strings","title":"Mention strings","text":"<p>You can use this annotation on both code-declared and annotation-declared commands</p> <p><code>@MentionsString</code> is an annotation that lets you retrieve as many mentions as a string option lets you type, you must use it on a <code>List</code> parameter with an element type supported by the annotation.</p> <p>You can also use a <code>List&lt;IMentionable&gt;</code>, where you can set the requested mention types.</p> <p>Note</p> <p>This won't restrict what the user can type on Discord, this only enables parsing mentions inside the string.</p> Bulk ban example  Kotlin Java <pre><code>@Command\nclass SlashBulkBan : ApplicationCommand() {\n    @JDASlashCommand(name = \"bulk_ban\", description = \"Ban users in bulk\")\n    suspend fun onSlashBulkBan(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"Users to ban\") @MentionsString users: List&lt;InputUser&gt;,\n        @SlashOption(description = \"Time frame of messages to delete\") timeframe: Long,\n        @SlashOption(description = \"Unit of the time frame\", usePredefinedChoices = true) unit: TimeUnit,\n    ) {\n        // Check if any member cannot be banned\n        val higherMembers = users.mapNotNull { it.member }.filterNot { event.guild.selfMember.canInteract(it) }\n        if (higherMembers.isNotEmpty()) {\n            return event.reply_(\"Cannot ban ${higherMembers.joinToString { it.asMention }} as they have equal/higher roles\", ephemeral = true).awaitUnit()\n        }\n\n        event.deferReply(true).queue()\n\n        event.guild.ban(users, timeframe.toDuration(unit.toDurationUnit())).awaitCatching()\n            // Make sure to use onSuccess first,\n            // as 'handle' will clear the result type\n            .onSuccess {\n                event.hook.send(\"Banned ${it.bannedUsers.size} users, ${it.failedUsers.size} failed\").await()\n            }\n            .handle(ErrorResponse.MISSING_PERMISSIONS) {\n                event.hook.send(\"Could not ban users due to missing permissions\").await()\n            }\n            .handle(ErrorResponse.FAILED_TO_BAN_USERS) {\n                event.hook.send(\"Could not ban anyone\").await()\n            }\n            // Throw unhandled exceptions\n            .getOrThrow()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashBulkBan extends ApplicationCommand {\n    @JDASlashCommand(name = \"bulk_ban\", description = \"Ban users in bulk\")\n    public void onSlashBulkBan(\n            GuildSlashEvent event,\n            @SlashOption(description = \"Users to ban\") @MentionsString List&lt;? extends InputUser&gt; users,\n            @SlashOption(description = \"Time frame of messages to delete\") Long timeframe,\n            @SlashOption(description = \"Unit of the time frame\", usePredefinedChoices = true) TimeUnit unit\n    ) {\n        // Check if any member cannot be banned\n        final var higherMembers = new ArrayList&lt;Member&gt;();\n        for (var user : users) {\n            final Member member = user.getMember();\n            if (member == null) continue;\n\n            if (!event.getGuild().getSelfMember().canInteract(member)) {\n                higherMembers.add(member);\n            }\n        }\n\n        if (!higherMembers.isEmpty()) {\n            final String mentions = higherMembers.stream().map(IMentionable::getAsMention).collect(Collectors.joining());\n            event.reply(\"Cannot ban \" + mentions + \" as they have equal/higher roles\")\n                    .setEphemeral(true)\n                    .queue();\n            return;\n        }\n\n        event.deferReply(true).queue();\n\n        event.getGuild().ban(users, Duration.of(timeframe, unit.toChronoUnit()))\n                .queue(response -&gt; {\n                    event.getHook().sendMessageFormat(\"Banned %s users, %s failed\", response.getBannedUsers().size(), response.getFailedUsers().size()).queue();\n                }, new ErrorHandler()\n                        .handle(ErrorResponse.MISSING_PERMISSIONS, exception -&gt; {\n                            event.getHook().sendMessage(\"Could not ban users due to missing permissions\").queue();\n                        })\n                        .handle(ErrorResponse.FAILED_TO_BAN_USERS, exception -&gt; {\n                            event.getHook().sendMessage(\"Could not ban anyone\").queue();\n                        })\n                );\n    }\n}\n</code></pre>"},{"location":"using-commands/advanced-options/#advanced-code-declared-options","title":"Advanced code-declared options","text":"<p>The Kotlin DSL also lets you do more, for example, using loops to generate commands, or even options. It also allows you to create more complex options, such as having multiple options in one parameter.</p> <p>Distinction between parameters and options</p> <p>Method parameters are what you expect, a simple value in your method, but for the framework, parameters might be a complex object (composed of multiple options), or a single option, whether it's an injected service, a Discord option or a generated value.</p> <p>i.e., A parameter might be a single or multiple options, but an option is always a single value.</p>"},{"location":"using-commands/advanced-options/#composite-parameters","title":"Composite parameters","text":"<p>These are parameters composed of multiple options, of any type, which gets merged into one parameter by using an aggregator.</p> <p>Tip</p> <p>This is how varargs are implemented, they are a loop that generates N options, where X options are optional.</p> <p>Creating an aggregated parameter</p> <p>Here is how you can use aggregated parameters to create a message delete timeframe, out of a <code>Long</code> and a <code>TimeUnit</code>.</p> The aggregated object<pre><code>// This data class is practically pointless;\n// this is just to demonstrate how you can group parameters together,\n// so you can benefit from functions/backed properties limited to your parameters,\n// without polluting classes with extensions\ndata class DeleteTimeframe(val time: Long, val unit: TimeUnit) {\n    override fun toString(): String = \"$time ${unit.name.lowercase()}\"\n}\n</code></pre> The aggregated parameter declaration<pre><code>@Command\nclass SlashBan {\n    @AppDeclaration\n    fun onDeclare(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"ban\", function = SlashBan::onSlashBan) {\n            ...\n\n            aggregate(declaredName = \"timeframe\", aggregator = ::DeleteTimeframe) {\n                option(declaredName = \"time\") {\n                    description = \"The timeframe of messages to delete with the specified unit\"\n                }\n\n                option(declaredName = \"unit\") {\n                    description = \"The unit of the delete timeframe\"\n\n                    usePredefinedChoices = true\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The aggregating function can be a reference to the object's constructor, or a function taking the options and returning an object of the corresponding type. </p>"},{"location":"using-commands/advanced-options/#kotlins-inline-classes","title":"Kotlin's inline classes","text":"<p>Input options as well as varargs can be encapsulated in an inline class, allowing you to define simple computable properties and functions for types where defining an extension makes no sense. (Like adding an extension, that's specific to only one command, on a <code>String</code>)</p> <p>Using inline classes</p> <pre><code>private val spaceDelimiter = Regex(\"\"\"\\s+\"\"\")\n\n@JvmInline\nvalue class Sentence(val value: String) {\n    val words: List&lt;String&gt; get() = spaceDelimiter.split(value)\n}\n\n@Command\nclass SlashInlineWords : ApplicationCommand() {\n    @JDASlashCommand(name = \"words\", description = \"Extracts the words of a sentence\")\n    suspend fun onSlashWords(event: GuildSlashEvent, @SlashOption(description = \"Input sentence\") sentence: Sentence) {\n        event.reply_(\"The words are: ${sentence.words}\", ephemeral = true).await()\n    }\n}\n</code></pre>"},{"location":"using-commands/common-command-details/","title":"Common command details","text":"<p>All commands can be defined by either using annotations or a DSL (for Kotlin users).</p> <p>In both cases, classes containing commands need to be annotated with <code>@Command</code>,  which will also register your class for dependency injection.</p>"},{"location":"using-commands/common-command-details/#defining-the-command-method","title":"Defining the command method","text":"<p>Whether you're using annotated or DSL commands, you will have to write a method, which holds the user inputs as parameters.</p> <p>The method must be public, non-static, with the first parameter being the event required for the command type of your choice.</p> <p>The command methods support coroutines, as well as nullable options, and optionals.</p> A slash command with everything mentioned above  Kotlin Java <pre><code>suspend fun example(event: GuildSlashEvent, string: String, user: User?, integer: Int = 42/*(1)!*/) {}    \n</code></pre> <ol> <li>Optional parameters make the Discord option optional too.</li> </ol> <pre><code>public void example(@NotNull GuildSlashEvent event, @NotNull String string, @Nullable User user) {}\n</code></pre>"},{"location":"using-commands/common-command-details/#annotated-commands","title":"Annotated commands","text":"<p>Annotations let you create commands easily, but are harder to read, cannot be created dynamically, and require usage of other methods to retrieve other values (such as choices for slash command options).</p> <p>Requirements of such commands are specified on the command annotation.</p>"},{"location":"using-commands/common-command-details/#dsl-commands-kotlin","title":"DSL commands (Kotlin)","text":"<p>DSL commands were added in V3 to help create commands dynamically, whether it's to let the user filter commands themselves, or adding subcommands/options in a loop; you can almost do anything you want while keeping the simplicity of your command method.</p> <p>Commands can be declared by implementing an interface, which will allow you to add commands using the provided manager.</p>"},{"location":"using-commands/application-commands/option-resolvers/","title":"Adding option resolvers","text":"<p>Option resolvers help you support other types for your command options, such as <code>TimeUnit</code>, or any object of your own.</p> <p>Slash command option resolvers specify which option type will be used on Discord, and will handle the conversion from the Discord value to the corresponding object.</p> <p>The class implementing the resolver, or the function returning a resolver, must be annotated with <code>@Resolver</code>.</p> <p>Note</p> <p><code>@Resolver</code> is one of the annotations that are considered as a service annotation. This means that it behaves exactly the same as if you had used <code>@BService</code>, except here the annotation is more meaningful.</p>"},{"location":"using-commands/application-commands/option-resolvers/#implementation","title":"Implementation","text":"<p>For that, you need a class annotated with <code>@Resolver</code> extending <code>ClassParameterResolver</code>, and implementing <code>SlashParameterResolver</code>.</p> <p>The first type parameter is the type of your resolver implementation, and the second type is what the resolver returns.</p> <p>A <code>TimeUnit</code> resolver</p>  Kotlin Java <pre><code>@Resolver\nclass TimeUnitResolver :\n    ClassParameterResolver&lt;TimeUnitResolver, TimeUnit&gt;(TimeUnit::class),\n    SlashParameterResolver&lt;TimeUnitResolver, TimeUnit&gt; {\n\n    override val optionType: OptionType = OptionType.STRING\n\n    // This is all you need to implement to support predefined choices\n    override fun getPredefinedChoices(guild: Guild?): Collection&lt;Choice&gt; {\n        return listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n            // The Resolvers class helps us by providing resolvers for any enum type.\n            // We're just using the helper method to change an enum value to a more natural name.\n            .map { Choice(it.toHumanName(), it.name) }\n    }\n\n    override suspend fun resolveSuspend(\n        option: SlashCommandOption,\n        event: CommandInteractionPayload,\n        optionMapping: OptionMapping\n    ): TimeUnit = enumValueOf&lt;TimeUnit&gt;(optionMapping.asString)\n}\n</code></pre> <pre><code>@Resolver\npublic class TimeUnitResolver\n        extends ClassParameterResolver&lt;TimeUnitResolver, TimeUnit&gt;\n        implements SlashParameterResolver&lt;TimeUnitResolver, TimeUnit&gt; {\n\n    public TimeUnitResolver() {\n        super(TimeUnit.class);\n    }\n\n    @NotNull\n    @Override\n    public OptionType getOptionType() {\n        return OptionType.STRING;\n    }\n\n    @NotNull\n    @Override\n    public Collection&lt;Command.Choice&gt; getPredefinedChoices(@Nullable Guild guild) {\n        return Stream.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                // The Resolvers class helps us by providing resolvers for any enum type.\n                // We're just using the helper method to change an enum value to a more natural name.\n                .map(u -&gt; new Command.Choice(Resolvers.toHumanName(u), u.name()))\n                .toList();\n    }\n\n    @Nullable\n    @Override\n    public TimeUnit resolve(@NotNull SlashCommandOption option, @NotNull CommandInteractionPayload event, @NotNull OptionMapping optionMapping) {\n        return TimeUnit.valueOf(optionMapping.getAsString());\n    }\n}\n</code></pre> <p>As you can see, this defines the slash command's option to be a string,  and provides predefined choices, letting you easily use them in your commands.</p> <p>Creating resolvers for parametrized types</p> <p>You can also extend <code>TypedParameterResolver</code> for use with parametrized type, Kotlin users can pass a KType directly, using <code>typeOf</code>, but Java users can use a <code>KotlinTypeToken</code> instead.</p>"},{"location":"using-commands/application-commands/option-resolvers/#built-in-resolver-generators","title":"Built-in resolver generators","text":"<p>The framework also provides functions in <code>Resolvers</code> to do most of the work for some types, all you need to do is declare a service factory with <code>@Resolver</code> and use the provided methods.</p> <p>Note</p> <p>Currently there is only a factory for enum resolvers, but others might be added in the future.</p> <p>How to easily make a resolver for an enum type</p>  Kotlin Java <p><pre><code>object TimeUnitResolverSimplified {\n    // The displayed name should be lowercase with the first letter uppercase, see Resolvers#toHumanName\n    @Resolver\n    fun getTimeUnitResolverSimplified() = enumResolver&lt;TimeUnit&gt;(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n}\n</code></pre> As this functions as a service factory, the method needs to be in an <code>object</code> or have a no-arg constructor.</p> <p><pre><code>public class TimeUnitResolverSimplifiedJava {\n    @Resolver\n    public static ParameterResolver&lt;?, TimeUnit&gt; getTimeUnitResolverSimplified() {\n        // The displayed name should be lowercase with the first letter uppercase, see Resolvers#toHumanName\n        return Resolvers.enumResolver(TimeUnit.class, EnumSet.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)).build();\n    }\n}\n</code></pre> As this functions as a service factory, the method needs to be static.</p>"},{"location":"using-commands/application-commands/using-autocomplete/","title":"Using autocomplete","text":"<p>Autocomplete lets you have options where you can give suggestions to the user while they type, the framework allows you to return a collection of choices,  choice-compatible types such as <code>String</code>, <code>Long</code> and <code>Double</code>, or even custom types, all of which can be cached.</p> <p>Note</p> <p>Autocompleted options do not force the user to choose one of the returned choices, they can still type anything.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#creating-autocomplete-handlers","title":"Creating autocomplete handlers","text":"Code-declaredAnnotated <p>You will have to implement the <code>AutocompleteHandlerProvider</code>, enabling you to declare autocomplete handlers using the manager.</p> <p>You can optionally put a name on the handler, if you plan on using <code>autocompleteByName</code>,  however, that's not necessary when using <code>autocompleteByFunction</code>.</p> <pre><code>@BService\nclass SlashWordAutocompleteDsl : AutocompleteHandlerProvider {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private val words = listOf(\n        \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n        \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n        \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    )\n\n    // You can also make this return a collection of Choice, see the AutocompleteManager#autocomplete docs\n    fun onWordAutocomplete(event: CommandAutoCompleteInteractionEvent): Collection&lt;String&gt; {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return words\n    }\n\n    // All autocomplete declarations run before any command is registered,\n    // so you can, in theory, add autocomplete handlers anywhere,\n    // and use them in any command.\n    override fun declareAutocomplete(manager: AutocompleteManager) {\n        manager.autocomplete(::onWordAutocomplete)\n    }\n}\n</code></pre> <p>You will have to use <code>@AutocompleteHandler</code>, give it a unique name, I'd recommend using one similar to <code>ClassName: optionName</code>, it will be useful to reference it in commands later on.</p> <p>Info</p> <p>An annotated autocomplete handler can still be referenced by name  and by function in code-declared commands.</p>  Kotlin Java <pre><code>@Handler // Required by the AutocompleteHandler annotation, can be replaced with @Command\nclass SlashWordAutocomplete {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private val words = listOf(\n        \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n        \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n        \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    )\n\n    // You can also make this return a collection of Choice, see the annotation docs\n    @AutocompleteHandler(WORD_AUTOCOMPLETE_NAME)\n    fun onWordAutocomplete(event: CommandAutoCompleteInteractionEvent): Collection&lt;String&gt; {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return words\n    }\n\n    companion object {\n        const val WORD_AUTOCOMPLETE_NAME = \"SlashWord: word\"\n    }\n}\n</code></pre> <pre><code>@Handler // Required by the AutocompleteHandler annotation, can be replaced with @Command\npublic class SlashWordAutocomplete extends ApplicationCommand {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private static final List&lt;String&gt; WORDS = List.of(\n            \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n            \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n            \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    );\n    public static final String WORD_AUTOCOMPLETE_NAME = \"SlashWord: word\";\n\n    // You can also make this return a collection of Choice, see the annotation docs\n    @AutocompleteHandler(WORD_AUTOCOMPLETE_NAME)\n    public Collection&lt;String&gt; onWordAutocomplete(CommandAutoCompleteInteractionEvent event) {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return WORDS;\n    }\n}\n</code></pre> <p>You may also configure other properties:</p> <ul> <li><code>showUserInput</code>: Makes the first choice be the user's own input</li> <li><code>mode</code>: Lets you configure out the automatic choice sorter (for <code>String</code>/<code>Long</code>/<code>Double</code> only)</li> </ul> <p>Sorting autocomplete results of <code>Choice</code> and custom types</p> <p>Sorting results by relevancy is a tricky task, while it can be as simple as <code>myItemName.startsWith(input)</code> you can try to use <code>AutocompleteAlgorithms</code> to easily sort the results.  This is what gets applied on primitive types, but the results won't always be the best.</p> <p>It may sometimes makes more sense to use one \"similarity\" algorithm over another,  depending on what user input you expect, and what the source items are, you can experiment different algos from the java-string-similarity library, already included in the framework.</p> <p>You are encouraged to to try inputs against different algos, and find what works the best,  which one could filter the results of the previous algo, etc.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#caching","title":"Caching","text":"<p>When the results are stable, you can enable autocomplete caching, saving time when a user types the same query.</p> Code-declaredAnnotated <p>To enable it, configure the cache using the <code>cache</code> configurer.</p> <p>By default it will cache by using the user input, but you can add arguments to the cache key by:</p> <ul> <li>Adding the user ID with <code>userLocal</code></li> <li>Adding the channel ID with <code>channelLocal</code></li> <li>Adding the guild ID with <code>guildLocal</code></li> <li>Adding values of options by their names in <code>compositeKeys</code> </li> </ul> <p>To enable it, configure the cache using <code>@CacheAutocomplete</code>.</p> <p>By default it will cache by using the user input, but you can add arguments to the cache key by:</p> <ul> <li>Adding the user ID with <code>userLocal</code></li> <li>Adding the channel ID with <code>channelLocal</code></li> <li>Adding the guild ID with <code>guildLocal</code></li> <li>Adding values of options by their names in <code>compositeKeys</code></li> </ul> <p>Note</p> <p>If the outputs for the same input are stable but may rarely change (think, a list that updates daily), you can invalidate autocomplete caches when it eventually does.</p> <p>Tip</p> <p>You can also disable the autocomplete cache while developing your bot with the disableAutocompleteCache property, this should help you test your handler live, using hotswap.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#transforming-elements-into-choices","title":"Transforming elements into choices","text":"<p>If you wish to return collections of anything but the default supported types, you will need to create a service which transforms those objects into choices, by implementing <code>AutocompleteTransformer</code>.</p> <p>Example</p>  Kotlin Java FullName.kt<pre><code>data class FullName(val firstName: String, val secondName: String)\n</code></pre> FullNameTransformer.kt<pre><code>@BService\nclass FullNameTransformer : AutocompleteTransformer&lt;FullName&gt; {\n    override val elementType: Class&lt;FullName&gt; = FullName::class.java\n\n    override fun apply(e: FullName): Command.Choice {\n        return Command.Choice(\"${e.firstName} ${e.secondName}\", \"${e.firstName}|${e.secondName}\")\n    }\n}\n</code></pre> FullName.java<pre><code>public record FullName(String firstName, String secondName) { }\n</code></pre> FullNameTransformer.java<pre><code>@BService\npublic class FullNameTransformer implements AutocompleteTransformer&lt;FullName&gt; {\n    @NotNull\n    @Override\n    public Class&lt;FullName&gt; getElementType() {\n        return FullName.class;\n    }\n\n    @NotNull\n    @Override\n    public Command.Choice apply(@NotNull FullName fullName) {\n        return new Command.Choice(\n                \"%s %s\".formatted(fullName.firstName(), fullName.secondName()),\n                \"%s|%s\".formatted(fullName, fullName.secondName())\n        );\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/using-autocomplete/#usage-in-commands","title":"Usage in commands","text":"<p>Discover how to use your autocomplete handlers on:</p> <ul> <li>Annotated slash commands</li> <li>Code-declared slash commands</li> </ul>"},{"location":"using-commands/application-commands/writing-slash-commands/","title":"Creating slash commands","text":"<p>Slash commands are the new way of defining commands, even though there are limitations with them,  we do have some advantages such as being easier to fill in, choices and auto-completion.</p> <p>If you wish to handle application commands yourself, you can disable them by disabling <code>BApplicationConfigBuilder.enable</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#defining-the-command-method","title":"Defining the command method","text":"<p>Tip</p> <p>Make sure you read the common command requirements first!</p> <p>In addition to the common requirements, the first parameter must be <code>GlobalSlashEvent</code> for global commands or <code>GuildSlashEvent</code> for guild commands, or guild-only global commands (default).</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#annotated-commands","title":"Annotated commands","text":"<p>Annotated command methods must be annotated with <code>@JDASlashCommand</code>, where you can set the scope, name, description, etc...,  while the declaring class must extend <code>ApplicationCommand</code>.</p> <p>Why do I need to extend <code>ApplicationCommand</code>?</p> <p>As a limitation of annotated commands,  you are required to extend this class as it allows the framework to ask your commands for stuff, like what guilds a command should be pushed to, getting a value generator for one of their options, and also getting choices.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashPingKotlin : ApplicationCommand() {\n    // Default scope is global, guild-only (GUILD_NO_DM)\n    @JDASlashCommand(name = \"ping\", description = \"Pong!\")\n    suspend fun onSlashPing(event: GuildSlashEvent) {\n        event.deferReply(true).queue()\n\n        val ping = event.jda.getRestPing().await()\n        event.hook.editOriginal(\"Pong! $ping ms\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashPing extends ApplicationCommand {\n    // Default scope is global, guild-only (GUILD_NO_DM)\n    @JDASlashCommand(name = \"ping\", description = \"Pong!\")\n    public void onSlashPing(GuildSlashEvent event) {\n        event.deferReply(true).queue();\n\n        event.getJDA().getRestPing().queue(ping -&gt; {\n            event.getHook().editOriginal(\"Pong! \" + ping + \" ms\").queue();\n        });\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#top-level-configuration","title":"Top level configuration","text":"<p>You can configure properties which only applies to top-level commands, using <code>@TopLevelSlashCommandData</code>, this includes elements such as the <code>scope</code> (guild, global or global without DMs), <code>description</code> and whether the command is locked to admins by default.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#subcommands","title":"Subcommands","text":"<p>To make a subcommand, set the <code>name</code> and <code>subcommand</code> on the annotation.</p> <p>You will also need to add a <code>@TopLevelSlashCommandData</code>, it must only be used once per top-level command, this allows you to set top-level attributes.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashTag : ApplicationCommand() {\n    // Data for /tag create\n    @JDASlashCommand(name = \"tag\", subcommand = \"create\", description = \"Creates a tag\")\n    // Data for /tag\n    @TopLevelSlashCommandData(description = \"Manage tags\")\n    fun onSlashTagCreate(event: GuildSlashEvent) {\n        // ...\n    }\n\n    // Data for /tag delete\n    @JDASlashCommand(name = \"tag\", subcommand = \"delete\", description = \"Deletes a tag\")\n    fun onSlashTagDelete(event: GuildSlashEvent) {\n        // ...\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashTag extends ApplicationCommand {\n    // Data for /tag create\n    @JDASlashCommand(name = \"tag\", subcommand = \"create\", description = \"Creates a tag\")\n    // Data for /tag\n    @TopLevelSlashCommandData(description = \"Manage tags\")\n    public void onSlashTagCreate(GuildSlashEvent event) {\n        // ...\n    }\n\n    // Data for /tag delete\n    @JDASlashCommand(name = \"tag\", subcommand = \"delete\", description = \"Deletes a tag\")\n    public void onSlashTagDelete(GuildSlashEvent event) {\n        // ...\n    }\n}\n</code></pre> <p>Note</p> <p>You cannot have both subcommands and top-level commands (i.e., an annotation with only <code>name</code> set).</p> <p>However, you can have both subcommand groups and subcommands groups containing subcommands.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#adding-options","title":"Adding options","text":"<p>Options can be added with a parameter annotated with <code>@SlashOption</code>.</p> <p>All supported types are documented under <code>ParameterResolver</code>, and other types can be added.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashSayKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"say\", description = \"Says something\")\n    suspend fun onSlashSay(event: GuildSlashEvent, @SlashOption(description = \"What to say\") content: String) {\n        event.reply(content).await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashSay extends ApplicationCommand {\n    @JDASlashCommand(name = \"say\", description = \"Says something\")\n    public void onSlashSay(GuildSlashEvent event, @SlashOption(description = \"What to say\") String content) {\n        event.reply(content).queue();\n    }\n}\n</code></pre> <p>Inferred option names</p> <p>Display names of options can be set on the annotation, but can also be deduced from the parameter name, this is natively supported in Kotlin, but for Java, you will need to enable parameter names on the Java compiler.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-choices","title":"Using choices","text":"<p>You must override <code>getOptionChoices</code> in order to return a list of choices,  be careful to check against the command path as well as the option's display name.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashConvertKotlin : ApplicationCommand() {\n    override fun getOptionChoices(guild: Guild?, commandPath: CommandPath, optionName: String): List&lt;Choice&gt; {\n        if (commandPath.name == \"convert\") {\n            if (optionName == \"from\" || optionName == \"to\") {\n                return listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n        }\n\n        return super.getOptionChoices(guild, commandPath, optionName)\n    }\n\n    @JDASlashCommand(name = \"convert\", description = \"Convert time to another unit\")\n    suspend fun onSlashConvert(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The time to convert\") time: Long,\n        @SlashOption(description = \"The unit to convert from\") from: TimeUnit,\n        @SlashOption(description = \"The unit to convert to\") to: TimeUnit\n    ) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashConvert extends ApplicationCommand {\n    @NotNull\n    @Override\n    public List&lt;Choice&gt; getOptionChoices(@Nullable Guild guild, @NotNull CommandPath commandPath, @NotNull String optionName) {\n        if (commandPath.getName().equals(\"convert\")) {\n            if (optionName.equals(\"from\") || optionName.equals(\"to\")) {\n                return Stream.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                        // The Resolvers class helps us by providing resolvers for any enum type.\n                        // We're just using the helper method to change an enum value to a more natural name.\n                        .map(u -&gt; new Choice(Resolvers.toHumanName(u), u.name()))\n                        .toList();\n            }\n        }\n\n        return super.getOptionChoices(guild, commandPath, optionName);\n    }\n\n    @JDASlashCommand(name = \"convert\", description = \"Convert time to another unit\")\n    public void onSlashConvert(\n            GuildSlashEvent event,\n            @SlashOption(description = \"The time to convert\") long time,\n            @SlashOption(description = \"The unit to convert from\") TimeUnit from,\n            @SlashOption(description = \"The unit to convert to\") TimeUnit to\n    ) {\n        event.reply(to.convert(time, from) + \" \" + to.name().toLowerCase()).queue();\n    }\n}\n</code></pre> <p>As you can see, despite the short choice list,  the method is quite lengthy and causes duplications with multiple commands. This issue is solved with predefined choices.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-autocomplete","title":"Using autocomplete","text":"<p>Learn how to create an autocomplete handler here</p> <p>Enabling autocompletion for an option is done by referencing an existing handler, in the <code>autocomplete</code> property of your <code>@SlashOption</code>.</p> <p>Example</p> <p>Using the autocomplete handler we made \"Creating autocomplete handlers\":</p>  Kotlin Java <pre><code>@Command\nclass SlashWord : ApplicationCommand() {\n    @JDASlashCommand(name = \"word\", description = \"Autocompletes a word\")\n    suspend fun onSlashWord(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The word\", autocomplete = SlashWordAutocomplete.WORD_AUTOCOMPLETE_NAME) word: String,\n    ) {\n        event.reply_(\"Your word was $word\", ephemeral = true).await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashWord extends ApplicationCommand {\n    @JDASlashCommand(name = \"word\", description = \"Autocompletes a word\")\n    public void onSlashWord(GuildSlashEvent event,\n                            @SlashOption(description = \"The word\", autocomplete = SlashWordAutocomplete.WORD_AUTOCOMPLETE_NAME) String word) {\n        event.reply(\"Your word was \" + word).setEphemeral(true).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#generated-values","title":"Generated values","text":"<p>Generated values are parameters that get their values from a lambda everytime a command is run.</p> <p>You must give one by overriding <code>ApplicationCommand.getGeneratedValueSupplier</code>,  similarly to adding choices.</p> <p>As always, make sure to check against the command path as well as the option's display name.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashCreateTimeKotlin : ApplicationCommand() {\n    override fun getGeneratedValueSupplier(\n        guild: Guild?,\n        commandId: String?,\n        commandPath: CommandPath,\n        optionName: String,\n        parameterType: ParameterType\n    ): ApplicationGeneratedValueSupplier {\n        if (commandPath.name == \"create_time\") {\n            if (optionName == \"timestamp\") {\n                // Create a snapshot of the instant the command was created\n                val now = Instant.now()\n                // Give back the instant snapshot, as this will be called every time the command runs\n                return ApplicationGeneratedValueSupplier { now }\n            }\n        }\n\n        return super.getGeneratedValueSupplier(guild, commandId, commandPath, optionName, parameterType)\n    }\n\n    @JDASlashCommand(name = \"create_time\", description = \"Shows the creation time of this command\")\n    suspend fun onSlashCreateTime(\n        event: GuildSlashEvent,\n        @GeneratedOption timestamp: Instant\n    ) {\n        event.reply(\"I was created on ${TimeFormat.DATE_TIME_SHORT.format(timestamp)}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashCreateTime extends ApplicationCommand {\n    @NotNull\n    @Override\n    public ApplicationGeneratedValueSupplier getGeneratedValueSupplier(\n            @Nullable Guild guild,\n            @Nullable String commandId,\n            @NotNull CommandPath commandPath,\n            @NotNull String optionName,\n            @NotNull ParameterType parameterType\n    ) {\n        if (commandPath.getName().equals(\"create_time\")) {\n            if (optionName.equals(\"timestamp\")) {\n                // Create a snapshot of the instant the command was created\n                final Instant now = Instant.now();\n                // Give back the instant snapshot, as this will be called every time the command runs\n                return event -&gt; now;\n            }\n        }\n\n        return super.getGeneratedValueSupplier(guild, commandId, commandPath, optionName, parameterType);\n    }\n\n    @JDASlashCommand(name = \"create_time\", description = \"Shows the creation time of this command\")\n    public void onSlashTimeIn(\n            GuildSlashEvent event,\n            @GeneratedOption Instant timestamp\n    ) {\n        event.reply(\"I was created on \" + TimeFormat.DATE_TIME_SHORT.format(timestamp)).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#rate-limiting","title":"Rate limiting","text":"<p>This lets you reject application commands if the user tries to use them too often.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-an-anonymous-rate-limiter","title":"Using an (anonymous) rate limiter","text":"<p>Use <code>@RateLimit</code> or <code>@Cooldown</code> to define one on an application command.</p>  Kotlin Java <pre><code>@Command\nclass SlashRateLimit : ApplicationCommand() {\n\n    // A rate limit for this slash command only\n    @RateLimit(\n        // Apply to each user, regardless of channel/guild\n        scope = RateLimitScope.USER,\n        // Delete the message telling the user about the remaining rate limit after it expires\n        deleteOnRefill = true,\n        // At least one of those needs to be empty for the command to be rejected\n        bandwidths = [\n            // 5 uses, 5 tokens gets added gradually over an hour (so, 1 token every 12 minutes)\n            Bandwidth(\n                capacity = 5, // 5 uses\n                Refill(\n                    type = RefillType.GREEDY,       // Gradually\n                    tokens = 5,                     // gives 5 tokens\n                    period = 1,                     // every 1\n                    periodUnit = ChronoUnit.HOURS   // hour\n                )\n            ),\n            // 2 uses, 2 tokens gets added at once after 2 minutes\n            // This is to prevent the user from spamming the command\n            Bandwidth(\n                capacity = 2, // 2 uses\n                Refill(\n                    type = RefillType.INTERVAL,     // At once,\n                    tokens = 2,                     // give 2 tokens\n                    period = 2,                     // every 2\n                    periodUnit = ChronoUnit.MINUTES // minutes\n                )\n            ),\n        ]\n    )\n    @JDASlashCommand(name = \"rate_limit\")\n    suspend fun onSlashRateLimit(event: GuildSlashEvent) {\n        event.reply(\"Hello world!\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashRateLimit extends ApplicationCommand {\n\n    // A rate limit for this slash command only\n    @RateLimit(\n            // Apply to each user, regardless of channel/guild\n            scope = RateLimitScope.USER,\n            // Delete the message telling the user about the remaining rate limit after it expires\n            deleteOnRefill = true,\n            // At least one of those needs to be empty for the command to be rejected\n            bandwidths = {\n                    // 5 uses, 5 tokens gets added gradually over an hour (so, 1 token every 12 minutes)\n                    @Bandwidth(\n                            capacity = 5, // 5 uses\n                            refill = @Refill(\n                                    type = RefillType.GREEDY,       // Gradually\n                                    tokens = 5,                     // gives 5 tokens\n                                    period = 1,                     // every 1\n                                    periodUnit = ChronoUnit.HOURS   // hour\n                            )\n                    ),\n                    // 2 uses, 2 tokens gets added at once after 2 minutes\n                    // This is to prevent the user from spamming the command\n                    @Bandwidth(\n                            capacity = 2, // 2 uses\n                            refill = @Refill(\n                                    type = RefillType.INTERVAL,     // At once,\n                                    tokens = 2,                     // give 2 tokens\n                                    period = 2,                     // every 2\n                                    periodUnit = ChronoUnit.MINUTES // minutes\n                            )\n                    ),\n            }\n    )\n    @JDASlashCommand(name = \"rate_limit\")\n    public void onSlashRateLimit(GuildSlashEvent event) {\n        event.reply(\"Hello world!\").queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-an-existing-rate-limiter","title":"Using an existing rate limiter","text":"<p>Nothing as simple as using <code>@RateLimitReference</code> with the <code>group</code> of a rate limiter defined in a <code>RateLimitProvider</code>.</p> <p>Learn how to create a rate limiter with \"Defining a rate limit\"</p>  Kotlin Java <pre><code>@BService\nclass WikiRateLimitProvider : RateLimitProvider {\n\n    override fun declareRateLimit(manager: RateLimitManager) {\n        // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n        val bucketConfiguration = Buckets.spikeProtected(\n            capacity = 5,               // 5 uses\n            duration = 1.hours,         // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n            spikeCapacity = 2,          // 2 uses\n            spikeDuration = 2.minutes   // Give 2 tokens every 2 minutes\n        )\n\n        val rateLimiter = RateLimiter.createDefault(\n            // Apply to each user, regardless of channel/guild\n            RateLimitScope.USER,\n            // Delete the message telling the user about the remaining rate limit after it expires\n            deleteOnRefill = true,\n            // Give our constant bucket configuration\n            configurationSupplier = bucketConfiguration.toSupplier()\n        )\n\n        // Register, any command can use it\n        manager.rateLimit(RATE_LIMIT_GROUP, rateLimiter)\n    }\n\n    companion object {\n        // The name of the rate limit, so you can reference it in your commands/components\n        const val RATE_LIMIT_GROUP = \"Wiki\"\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashRateLimitExisting : ApplicationCommand() {\n\n    // A rate limit for this slash command only\n    @RateLimitReference(WikiRateLimitProvider.RATE_LIMIT_GROUP)\n    @JDASlashCommand(name = \"rate_limit_existing\")\n    suspend fun onSlashRateLimit(event: GuildSlashEvent) {\n        event.reply(\"Hello world!\").await()\n    }\n}\n</code></pre> <pre><code>@BService\npublic class WikiRateLimitProvider implements RateLimitProvider {\n    // The name of the rate limit, so you can reference it in your commands/components\n    public static final String RATE_LIMIT_GROUP = \"Wiki\";\n\n    @Override\n    public void declareRateLimit(@NotNull RateLimitManager rateLimitManager) {\n        // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n        final var bucketConfiguration = Buckets.createSpikeProtected(\n                5,                      // 5 uses\n                Duration.ofHours(1),    // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n                2,                      // 2 uses\n                Duration.ofMinutes(2)   // Give 2 tokens every 2 minutes\n        );\n\n        final var rateLimiter = RateLimiter.createDefault(\n                // Apply to each user, regardless of channel/guild\n                RateLimitScope.USER,\n                // Give our constant bucket configuration\n                BucketConfigurationSupplier.constant(bucketConfiguration),\n                // Delete the message telling the user about the remaining rate limit after it expires\n                true\n        );\n\n        // Register\n        rateLimitManager.rateLimit(RATE_LIMIT_GROUP, rateLimiter);\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashRateLimitExisting extends ApplicationCommand {\n\n    // A rate limit for this slash command only\n    @RateLimitReference(WikiRateLimitProvider.RATE_LIMIT_GROUP)\n    @JDASlashCommand(name = \"rate_limit_existing\")\n    public void onSlashRateLimit(GuildSlashEvent event) {\n        event.reply(\"Hello world!\").queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#cooldown","title":"Cooldown","text":"<p>A cooldown is a rate limit, but with fewer parameters, it can be used as <code>@Cooldown(5, ChronoUnit.SECONDS /* also scope and deleteOnRefill */)</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#filtering-commands","title":"Filtering commands","text":"<p>You can use <code>@DeclarationFilter</code> if you wish to declare a guild command conditionally.</p> <p>Note</p> <p>There is no equivalent for DSL commands as you can check and return early with your own code.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#creating-the-filter","title":"Creating the filter","text":"<p>Create a service implementing <code>CommandDeclarationFilter</code>, and make the method return <code>true</code> if the command can be declared. All filters must return <code>true</code> for the command to be declared.</p> <p>Example</p>  Kotlin Java <pre><code>@BService\nclass BotOwnerIsGuildOwnerDeclarationFilter(\n    private val botOwners: BotOwners, // Provided by the framework\n) : CommandDeclarationFilter {\n\n    override fun filter(guild: Guild, path: CommandPath, commandId: String?): Boolean {\n        // Only allow this command to be in guilds owned by the bot owner\n        return guild.ownerIdLong in botOwners.ownerIds\n    }\n}\n</code></pre> <pre><code>@BService\npublic class BotOwnerIsGuildOwnerDeclarationFilter implements CommandDeclarationFilter {\n    private final BotOwners botOwners; // Provided by the framework\n\n    public BotOwnerIsGuildOwnerDeclarationFilter(BotOwners botOwners) {\n        this.botOwners = botOwners;\n    }\n\n    @Override\n    public boolean filter(@NotNull Guild guild, @NotNull CommandPath commandPath, @Nullable String s) {\n        // Only allow this command to be in guilds owned by the bot owner\n        return botOwners.getOwnerIds().contains(guild.getOwnerIdLong());\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-the-filter","title":"Using the filter","text":"<p>Add a <code>@DeclarationFilter</code> on your command and reference your filter inside it.</p> <p>Example</p>  Kotlin Java <pre><code>@Command\nclass SlashBotOwnerIsGuildOwner : ApplicationCommand() {\n\n    // All filters must return 'true' for the command to be declared\n    @DeclarationFilter(BotOwnerIsGuildOwnerDeclarationFilter::class)\n    // The command needs to be registered on guilds for it to be filtered\n    @TopLevelSlashCommandData(scope = CommandScope.GUILD)\n    @JDASlashCommand(name = \"bot_owner_is_guild_owner\")\n    suspend fun onSlashBotOwnerIsGuildOwner(event: GuildSlashEvent) {\n        event.reply_(\"You are the owner of this bot and guild!\", ephemeral = true).await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashBotOwnerIsGuildOwner extends ApplicationCommand {\n\n    // All filters must return 'true' for the command to be declared\n    @DeclarationFilter(BotOwnerIsGuildOwnerDeclarationFilter.class)\n    // The command needs to be registered on guilds for it to be filtered\n    @TopLevelSlashCommandData(scope = CommandScope.GUILD)\n    @JDASlashCommand(name = \"bot_owner_is_guild_owner\")\n    public void onSlashBotOwnerIsGuildOwner(GuildSlashEvent event) {\n        event.reply(\"You are the owner of this bot and guild!\")\n                .setEphemeral(true)\n                .queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#dsl-commands-kotlin","title":"DSL commands (Kotlin)","text":"<p>Commands can be DSL-declared by either implementing:</p> <ul> <li><code>GlobalApplicationCommandProvider</code> (for global / guild-only global application commands), or,</li> <li><code>GuildApplicationCommandProvider</code> (for guild-specific application commands)</li> </ul> <p>You can then use the <code>slashCommand</code> method on the <code>manager</code>, give it the command name, the command method,  and then configure your command.</p> <p>Tip</p> <p>You are allowed to not add any command at all, for example,  if the <code>guild</code> in <code>GuildApplicationCommandManager</code> isn't a guild you want the command to appear in.</p> <p>Example</p> <pre><code>@Command\nclass SlashPingKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashPing(event: GuildSlashEvent) {\n        event.deferReply(true).queue()\n\n        val ping = event.jda.getRestPing().await()\n        event.hook.editOriginal(\"Pong! $ping ms\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        // Default scope is global, guild-only (GUILD_NO_DM)\n        manager.slashCommand(\"ping\", function = ::onSlashPing) {\n            description = \"Pong!\"\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#subcommands_1","title":"Subcommands","text":"<p>As top-level commands cannot be made alongside subcommands, the top-level <code>function</code> must be <code>null</code>.</p> <p>You can then add a subcommand by using <code>subcommand</code>, where each subcommand is its own function.</p> <p>Example</p> <pre><code>@Command\nclass SlashTagDsl : GlobalApplicationCommandProvider {\n    fun onSlashTagCreate(event: GuildSlashEvent) {\n        // ...\n    }\n\n    fun onSlashTagDelete(event: GuildSlashEvent) {\n        // ...\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        // Pass a null function as this is not a top-level command\n        manager.slashCommand(\"tag\", function = null) {\n            description = \"Manage tags\"\n\n            subcommand(\"create\", ::onSlashTagCreate) {\n                description = \"Creates a tag\"\n            }\n\n            subcommand(\"delete\", ::onSlashTagDelete) {\n                description = \"Deletes a tag\"\n            }\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>You can still create both subcommands, and subcommand groups containg subcommands.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#adding-options_1","title":"Adding options","text":"<p>Options can be added with a parameter and declaring it using <code>option</code> in your command builder, where the <code>declaredName</code> is the name of your parameter, the block will let you change the description, choices, etc.</p> <p>All supported types are documented under <code>ParameterResolver</code>, and other types can be added.</p> <p>Example</p> <pre><code>@Command\nclass SlashSayKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashSay(event: GuildSlashEvent, content: String) {\n        event.reply(content).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"say\", function = ::onSlashSay) {\n            description = \"Says something\"\n\n            option(\"content\") {\n                description = \"What to say\"\n            }\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>You can override the option name by setting <code>optionName</code> in the option declaration: <pre><code>option(\"content\", optionName = \"sentence\") {\n    ...\n}\n</code></pre></p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-choices_1","title":"Using choices","text":"<p>Adding choices is very straight forward, you only have to give a list of choices to the <code>choice</code> property.</p> <p>Example</p> <pre><code>@Command\nclass SlashConvertKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashConvert(event: GuildSlashEvent, time: Long, from: TimeUnit, to: TimeUnit) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"convert\", function = ::onSlashConvert) {\n            description = \"Convert time to another unit\"\n\n            option(\"time\") {\n                description = \"The time to convert\"\n            }\n\n            option(\"from\") {\n                description = \"The unit to convert from\"\n\n                choices = listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n\n            option(\"to\") {\n                description = \"The unit to convert to\"\n\n                choices = listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n        }\n    }\n}\n</code></pre> <p>As you can see, despite the short choice list, this causes duplications with multiple commands. This issue is solved with predefined choices.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-autocomplete_1","title":"Using autocomplete","text":"<p>Learn how to create an autocomplete handler here</p> <p>Enabling autocompletion for an option is done by referencing an existing handler, either using <code>autocompleteByFunction</code> or <code>autocompleteByName</code>.</p> <p>Tip</p> <p>I recommend using <code>autocompleteByFunction</code> as it avoids typing the name twice.</p> <p>Example</p> <p>Using the autocomplete handler we made \"Creating autocomplete handlers\":</p> <pre><code>@Command\nclass SlashWordDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashWord(event: GuildSlashEvent, word: String) {\n        event.reply_(\"Your word was $word\", ephemeral = true).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"word\", function = ::onSlashWord) {\n            description = \"Autocompletes a word\"\n\n            option(\"word\") {\n                description = \"The word\"\n\n                // Use an existing autocomplete declaration\n                autocompleteByFunction(SlashWordAutocompleteDsl::onWordAutocomplete)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#rate-limiting_1","title":"Rate limiting","text":"<p>This lets you reject application commands if the user tries to use them too often.</p> <p>Learn how to create a rate limiter with \"Defining a rate limit\"</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-an-anonymous-rate-limiter_1","title":"Using an (anonymous) rate limiter","text":"<pre><code>@Command\nclass SlashRateLimitDsl : GlobalApplicationCommandProvider {\n\n    suspend fun onSlashRateLimit(event: GuildSlashEvent) {\n        event.reply(\"Hello world!\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"rate_limit_dsl\", function = ::onSlashRateLimit) {\n            // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n            val bucketConfiguration = Buckets.spikeProtected(\n                capacity = 5,               // 5 uses\n                duration = 1.hours,         // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n                spikeCapacity = 2,          // 2 uses\n                spikeDuration = 2.minutes   // Give 2 tokens every 2 minutes\n            )\n\n            val rateLimiter = RateLimiter.createDefault(\n                // Apply to each user, regardless of channel/guild\n                RateLimitScope.USER,\n                // Delete the message telling the user about the remaining rate limit after it expires\n                deleteOnRefill = true,\n                // Give our constant bucket configuration\n                configurationSupplier = bucketConfiguration.toSupplier()\n            )\n\n            rateLimit(rateLimiter)\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-an-existing-rate-limiter_1","title":"Using an existing rate limiter","text":"<p>Nothing as simple as using <code>rateLimitReference</code> with the <code>group</code> of a rate limiter defined in a <code>RateLimitProvider</code>.</p> <pre><code>@BService\nclass WikiRateLimitProvider : RateLimitProvider {\n\n    override fun declareRateLimit(manager: RateLimitManager) {\n        // Lets the user use the command 5 times in an hour, but also 2 times in 2 minutes to prevent spam\n        val bucketConfiguration = Buckets.spikeProtected(\n            capacity = 5,               // 5 uses\n            duration = 1.hours,         // Gives 5 tokens gradually, during an hour (1 token every 12 minutes)\n            spikeCapacity = 2,          // 2 uses\n            spikeDuration = 2.minutes   // Give 2 tokens every 2 minutes\n        )\n\n        val rateLimiter = RateLimiter.createDefault(\n            // Apply to each user, regardless of channel/guild\n            RateLimitScope.USER,\n            // Delete the message telling the user about the remaining rate limit after it expires\n            deleteOnRefill = true,\n            // Give our constant bucket configuration\n            configurationSupplier = bucketConfiguration.toSupplier()\n        )\n\n        // Register, any command can use it\n        manager.rateLimit(RATE_LIMIT_GROUP, rateLimiter)\n    }\n\n    companion object {\n        // The name of the rate limit, so you can reference it in your commands/components\n        const val RATE_LIMIT_GROUP = \"Wiki\"\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashRateLimitExistingDsl : GlobalApplicationCommandProvider {\n\n    suspend fun onSlashRateLimit(event: GuildSlashEvent) {\n        event.reply(\"Hello world!\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"rate_limit_existing_dsl\", function = ::onSlashRateLimit) {\n            // Use the rate limiter we defined in [[WikiRateLimitProvider]]\n            rateLimitReference(WikiRateLimitProvider.RATE_LIMIT_GROUP)\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#cooldown_1","title":"Cooldown","text":"<p>A cooldown is a rate limit, but with fewer parameters, it can be used as <code>cooldown(5.seconds /* also scope and deleteOnRefill */)</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#generated-values_1","title":"Generated values","text":"<p>Generated values are a command parameter that gets their values computed by the given block everytime the command run.</p> <p>Contrary to the annotated commands, no checks are required, as this is tied to the currently built command.</p> <p>Example</p> <pre><code>@Command\nclass SlashCreateTimeKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashCreateTime(event: GuildSlashEvent, timestamp: Instant) {\n        event.reply(\"I was created on ${TimeFormat.DATE_TIME_SHORT.format(timestamp)}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"create_time\", function = ::onSlashCreateTime) {\n            description = \"Shows the creation time of this command\"\n\n            // Create a snapshot of the instant the command was created\n            val now = Instant.now()\n            generatedOption(\"timestamp\") {\n                // Give back the instant snapshot, as this will be called every time the command is run\n                return@generatedOption now\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#default-description","title":"Default description","text":"<p>You can avoid setting the (non-localized) descriptions of your commands and options  by putting them in a localization file, using the root locale (i.e., no locale suffix), and have your localization bundle registered with <code>BApplicationConfigBuilder#addLocalizations</code>.</p> The same commands as before, but without the descriptions  KotlinKotlin (DSL) Java <pre><code>@Command\nclass SlashSayDefaultDescriptionKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"say_default_description\")\n    suspend fun onSlashSayDefaultDescription(event: GuildSlashEvent, @SlashOption content: String) {\n        event.reply(content).await()\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashSayDefaultDescriptionKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashSayDefaultDescription(event: GuildSlashEvent, content: String) {\n        event.reply(content).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"say_default_description\", function = ::onSlashSayDefaultDescription) {\n            option(\"content\")\n        }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashSayDefaultDescription extends ApplicationCommand {\n    @JDASlashCommand(name = \"say_default_description\")\n    public void onSlashSayDefaultDescription(GuildSlashEvent event, @SlashOption String content) {\n        event.reply(content).queue();\n    }\n}\n</code></pre> <p>Adding the root localization bundle</p> <p>For the given resource bundle: src/main/resources/bc_localization/Commands.json<pre><code>{\n  \"say_default_description\": {\n    \"description\": \"Says something\",\n    \"options\": {\n      \"content.description\": \"What to say\"\n    }\n  }\n}\n</code></pre></p> <p>You can add the bundle by calling <code>BApplicationConfigBuilder#addLocalizations(\"Commands\")</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-predefined-choices","title":"Using predefined choices","text":"<p>If your choices stay the same for every command, you can improve re-usability and avoid extra code by using choices on the resolver's level, that is, the resolver will return the choices used for every option of their type.</p> <p>All you now need to do is enable <code>usePredefinedChoices</code> on your option.</p> <p>Example</p> <p>Here, the resolver for <code>TimeUnit</code> is already defined and will be explained in Adding option resolvers.</p>  KotlinKotlin (DSL) Java <pre><code>@Command\nclass SlashConvertSimplifiedKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"convert_simplified\", description = \"Convert time to another unit\")\n    suspend fun onSlashConvertSimplified(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The time to convert\") time: Long,\n        @SlashOption(description = \"The unit to convert from\", usePredefinedChoices = true) from: TimeUnit,\n        @SlashOption(description = \"The unit to convert to\", usePredefinedChoices = true) to: TimeUnit\n    ) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashConvertSimplifiedKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashConvertSimplified(event: GuildSlashEvent, time: Long, from: TimeUnit, to: TimeUnit) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"convert_simplified\", function = ::onSlashConvertSimplified) {\n            description = \"Convert time to another unit\"\n\n            option(\"time\") {\n                description = \"The time to convert\"\n            }\n\n            option(\"from\") {\n                description = \"The unit to convert from\"\n\n                usePredefinedChoices = true\n            }\n\n            option(\"to\") {\n                description = \"The unit to convert to\"\n\n                usePredefinedChoices = true\n            }\n        }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashConvertSimplified extends ApplicationCommand {\n    @JDASlashCommand(name = \"convert_simplified\", description = \"Convert time to another unit\")\n    public void onSlashTimeInSimplified(\n            GuildSlashEvent event,\n            @SlashOption(description = \"The time to convert\") long time,\n            @SlashOption(description = \"The unit to convert from\", usePredefinedChoices = true) TimeUnit from,\n            @SlashOption(description = \"The unit to convert to\", usePredefinedChoices = true) TimeUnit to\n    ) {\n        event.reply(to.convert(time, from) + \" \" + to.toString().toLowerCase()).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#update-logs","title":"Update logs","text":"<p>You can optionally get more info on what changed in your application commands, by enabling the <code>TRACE</code> logs on <code>io.github.freya022.botcommands.internal.commands.application.diff.DiffLogger</code>, or any package it is in.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#examples","title":"Examples","text":"<p>You can take a look at more examples here.</p>"},{"location":"using-commands/text-commands/","title":"Text commands","text":"<p>Note</p> <p>This is a wiki stub, while this allows you to know such features exist, there is little to no content about it, however, you can:</p> <ul> <li>Ask questions about it in the support server</li> <li>Help create this wiki by contributing directly, or by suggesting what topics should be explained,   how they should be structured, give relevant use cases/examples...</li> </ul>"},{"location":"using-commands/text-commands/#help-command","title":"Help command","text":"<p>A built-in help command is available.</p>"},{"location":"using-commands/text-commands/#disabling-it","title":"Disabling it","text":"<p>You can disable them with <code>BTextConfigBuilder.isHelpDisabled</code>.</p>"},{"location":"using-commands/text-commands/#creating-your-own","title":"Creating your own","text":"<p>To replace the built-in help command, as well as handling invalid command usages, see <code>IHelpCommand</code>.</p>"},{"location":"using-commands/text-commands/writing-text-commands/","title":"Writing text commands","text":"<p>Note</p> <p>This is a wiki stub, while this allows you to know such features exist, there is little to no content about it, however, you can:</p> <ul> <li>Ask questions about it in the support server</li> <li>Help create this wiki by contributing directly, or by suggesting what topics should be explained,   how they should be structured, give relevant use cases/examples...</li> </ul> <p>Text commands are made very similarly to application commands, annotated or code-declared.</p>"}]}